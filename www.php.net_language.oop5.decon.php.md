# Constructors and Destructors




<div class="phpcode"><span class="html">
the easiest way to use and understand multiple constructors:
<br>
<br><span class="default">&lt;?php
<br></span><span class="keyword">class </span><span class="default">A
<br></span><span class="keyword">{
<br>&#xA0; &#xA0; function </span><span class="default">__construct</span><span class="keyword">()
<br>&#xA0; &#xA0; {
<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">func_get_args</span><span class="keyword">();
<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">func_num_args</span><span class="keyword">();
<br>&#xA0; &#xA0; &#xA0; &#xA0; if (</span><span class="default">method_exists</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">,</span><span class="default">$f</span><span class="keyword">=</span><span class="string">&apos;__construct&apos;</span><span class="keyword">.</span><span class="default">$i</span><span class="keyword">)) {
<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">call_user_func_array</span><span class="keyword">(array(</span><span class="default">$this</span><span class="keyword">,</span><span class="default">$f</span><span class="keyword">),</span><span class="default">$a</span><span class="keyword">);
<br>&#xA0; &#xA0; &#xA0; &#xA0; }
<br>&#xA0; &#xA0; }
<br>&#xA0; &#xA0; 
<br>&#xA0; &#xA0; function </span><span class="default">__construct1</span><span class="keyword">(</span><span class="default">$a1</span><span class="keyword">)
<br>&#xA0; &#xA0; {
<br>&#xA0; &#xA0; &#xA0; &#xA0; echo(</span><span class="string">&apos;__construct with 1 param called: &apos;</span><span class="keyword">.</span><span class="default">$a1</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">);
<br>&#xA0; &#xA0; }
<br>&#xA0; &#xA0; 
<br>&#xA0; &#xA0; function </span><span class="default">__construct2</span><span class="keyword">(</span><span class="default">$a1</span><span class="keyword">,</span><span class="default">$a2</span><span class="keyword">)
<br>&#xA0; &#xA0; {
<br>&#xA0; &#xA0; &#xA0; &#xA0; echo(</span><span class="string">&apos;__construct with 2 params called: &apos;</span><span class="keyword">.</span><span class="default">$a1</span><span class="keyword">.</span><span class="string">&apos;,&apos;</span><span class="keyword">.</span><span class="default">$a2</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">);
<br>&#xA0; &#xA0; }
<br>&#xA0; &#xA0; 
<br>&#xA0; &#xA0; function </span><span class="default">__construct3</span><span class="keyword">(</span><span class="default">$a1</span><span class="keyword">,</span><span class="default">$a2</span><span class="keyword">,</span><span class="default">$a3</span><span class="keyword">)
<br>&#xA0; &#xA0; {
<br>&#xA0; &#xA0; &#xA0; &#xA0; echo(</span><span class="string">&apos;__construct with 3 params called: &apos;</span><span class="keyword">.</span><span class="default">$a1</span><span class="keyword">.</span><span class="string">&apos;,&apos;</span><span class="keyword">.</span><span class="default">$a2</span><span class="keyword">.</span><span class="string">&apos;,&apos;</span><span class="keyword">.</span><span class="default">$a3</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">);
<br>&#xA0; &#xA0; }
<br>}
<br></span><span class="default">$o </span><span class="keyword">= new </span><span class="default">A</span><span class="keyword">(</span><span class="string">&apos;sheep&apos;</span><span class="keyword">);
<br></span><span class="default">$o </span><span class="keyword">= new </span><span class="default">A</span><span class="keyword">(</span><span class="string">&apos;sheep&apos;</span><span class="keyword">,</span><span class="string">&apos;cat&apos;</span><span class="keyword">);
<br></span><span class="default">$o </span><span class="keyword">= new </span><span class="default">A</span><span class="keyword">(</span><span class="string">&apos;sheep&apos;</span><span class="keyword">,</span><span class="string">&apos;cat&apos;</span><span class="keyword">,</span><span class="string">&apos;dog&apos;</span><span class="keyword">);
<br>
<br></span><span class="comment">// results:
<br>// __construct with 1 param called: sheep
<br>// __construct with 2 params called: sheep,cat
<br>// __construct with 3 params called: sheep,cat,dog
<br></span><span class="default">?&gt;</span>
</span>
</div>
  

#


<div class="phpcode"><span class="html">
Be aware of potential memory leaks caused by circular references within objects.&#xA0; The PHP manual states &quot;[t]he destructor method will be called as soon as all references to a particular object are removed&quot; and this is precisely true: if two objects reference each other (or even if one object has a field that points to itself as in $this-&gt;foo = $this) then this reference will prevent the destructor being called even when there are no other references to the object at all.&#xA0; The programmer can no longer access the objects, but they still stay in memory.<br><br>Consider the following example:<br><br><span class="default">&lt;?php<br><br>header</span><span class="keyword">(</span><span class="string">&quot;Content-type: text/plain&quot;</span><span class="keyword">);<br><br>class </span><span class="default">Foo </span><span class="keyword">{<br>&#xA0; &#xA0; <br>&#xA0; &#xA0; </span><span class="comment">/**<br>&#xA0; &#xA0;&#xA0; * An indentifier<br>&#xA0; &#xA0;&#xA0; * @var string <br>&#xA0; &#xA0;&#xA0; */<br>&#xA0; &#xA0; </span><span class="keyword">private </span><span class="default">$name</span><span class="keyword">;<br>&#xA0; &#xA0; </span><span class="comment">/**<br>&#xA0; &#xA0;&#xA0; * A reference to another Foo object<br>&#xA0; &#xA0;&#xA0; * @var Foo<br>&#xA0; &#xA0;&#xA0; */<br>&#xA0; &#xA0; </span><span class="keyword">private </span><span class="default">$link</span><span class="keyword">;<br><br>&#xA0; &#xA0; public function </span><span class="default">__construct</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">) {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">name </span><span class="keyword">= </span><span class="default">$name</span><span class="keyword">;<br>&#xA0; &#xA0; }<br><br>&#xA0; &#xA0; public function </span><span class="default">setLink</span><span class="keyword">(</span><span class="default">Foo $link</span><span class="keyword">){<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">link </span><span class="keyword">= </span><span class="default">$link</span><span class="keyword">;<br>&#xA0; &#xA0; }<br><br>&#xA0; &#xA0; public function </span><span class="default">__destruct</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; echo </span><span class="string">&apos;Destroying: &apos;</span><span class="keyword">, </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">name</span><span class="keyword">, </span><span class="default">PHP_EOL</span><span class="keyword">;<br>&#xA0; &#xA0; }<br>}<br><br></span><span class="comment">// create two Foo objects:<br></span><span class="default">$foo </span><span class="keyword">= new </span><span class="default">Foo</span><span class="keyword">(</span><span class="string">&apos;Foo 1&apos;</span><span class="keyword">);<br></span><span class="default">$bar </span><span class="keyword">= new </span><span class="default">Foo</span><span class="keyword">(</span><span class="string">&apos;Foo 2&apos;</span><span class="keyword">);<br><br></span><span class="comment">// make them point to each other<br></span><span class="default">$foo</span><span class="keyword">-&gt;</span><span class="default">setLink</span><span class="keyword">(</span><span class="default">$bar</span><span class="keyword">);<br></span><span class="default">$bar</span><span class="keyword">-&gt;</span><span class="default">setLink</span><span class="keyword">(</span><span class="default">$foo</span><span class="keyword">);<br><br></span><span class="comment">// destroy the global references to them<br></span><span class="default">$foo </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">;<br></span><span class="default">$bar </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">;<br><br></span><span class="comment">// we now have no way to access Foo 1 or Foo 2, so they OUGHT to be __destruct()ed<br>// but they are not, so we get a memory leak as they are still in memory.<br>//<br>// Uncomment the next line to see the difference when explicitly calling the GC:<br>// gc_collect_cycles();<br>// <br>// see also: <a href="http://www.php.net/manual/en/features.gc.php" rel="nofollow" target="_blank">http://www.php.net/manual/en/features.gc.php</a><br>// <br><br>// create two more Foo objects, but DO NOT set their internal Foo references<br>// so nothing except the vars $foo and $bar point to them:<br></span><span class="default">$foo </span><span class="keyword">= new </span><span class="default">Foo</span><span class="keyword">(</span><span class="string">&apos;Foo 3&apos;</span><span class="keyword">);<br></span><span class="default">$bar </span><span class="keyword">= new </span><span class="default">Foo</span><span class="keyword">(</span><span class="string">&apos;Foo 4&apos;</span><span class="keyword">);<br><br></span><span class="comment">// destroy the global references to them<br></span><span class="default">$foo </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">;<br></span><span class="default">$bar </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">;<br><br></span><span class="comment">// we now have no way to access Foo 3 or Foo 4 and as there are no more references<br>// to them anywhere, their __destruct() methods are automatically called here,<br>// BEFORE the next line is executed:<br><br></span><span class="keyword">echo </span><span class="string">&apos;End of script&apos;</span><span class="keyword">, </span><span class="default">PHP_EOL</span><span class="keyword">;<br><br></span><span class="default">?&gt;<br></span><br>This will output:<br><br>Destroying: Foo 3<br>Destroying: Foo 4<br>End of script<br>Destroying: Foo 1<br>Destroying: Foo 2<br><br>But if we uncomment the gc_collect_cycles(); function call in the middle of the script, we get:<br><br>Destroying: Foo 2<br>Destroying: Foo 1<br>Destroying: Foo 3<br>Destroying: Foo 4<br>End of script<br><br>As may be desired.<br><br>NOTE: calling gc_collect_cycles() does have a speed overhead, so only use it if you feel you need to.</span>
</div>
  

#


<div class="phpcode"><span class="html">
The __destruct magic method must be public. <br><br>public function __destruct()<br>{<br>&#xA0; &#xA0; ;<br>}<br><br>The method will automatically be called externally to the instance.&#xA0; Declaring __destruct as protected or private will result in a warning and the magic method will not be called. <br><br>Note: In PHP 5.3.10 i saw strange side effects while some Destructors were declared as protected.</span>
</div>
  

#


<div class="phpcode"><span class="html">
USE PARENT::CONSTRUCT() to exploit POLYMORPHISM POWERS<br><br>Since we are still in the __construct and __destruct section, alot of emphasis has been on __destruct - which I know nothing about. But I would like to show the power of parent::__construct for use with PHP&apos;s OOP polymorphic behavior (you&apos;ll see what this is very quickly).<br><br>In my example, I have created a fairly robust base class that does everything that all subclasses need to do. Here&apos;s the base class def.<br><br><span class="default">&lt;?php<br><br></span><span class="comment">/*<br> * Animal.php<br> *<br> * This class holds all data, and defines all functions that all <br> * subclass extensions need to use.<br> *<br> */<br></span><span class="keyword">abstract class </span><span class="default">Animal<br></span><span class="keyword">{<br>&#xA0; public </span><span class="default">$type</span><span class="keyword">;<br>&#xA0; public </span><span class="default">$name</span><span class="keyword">;<br>&#xA0; public </span><span class="default">$sound</span><span class="keyword">;<br><br>&#xA0; </span><span class="comment">/*<br>&#xA0;&#xA0; * called by Dog, Cat, Bird, etc.<br>&#xA0;&#xA0; */<br>&#xA0; </span><span class="keyword">public function </span><span class="default">__construct</span><span class="keyword">(</span><span class="default">$aType</span><span class="keyword">, </span><span class="default">$aName</span><span class="keyword">, </span><span class="default">$aSound</span><span class="keyword">)<br>&#xA0; {<br>&#xA0; &#xA0; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">type </span><span class="keyword">= </span><span class="default">$aType</span><span class="keyword">;<br>&#xA0; &#xA0; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">name </span><span class="keyword">= </span><span class="default">$aName</span><span class="keyword">;<br>&#xA0; &#xA0; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">sound </span><span class="keyword">= </span><span class="default">$aSound</span><span class="keyword">;<br>&#xA0; }<br><br>&#xA0; </span><span class="comment">/*<br>&#xA0;&#xA0; * define the sorting rules - we will sort all Animals by name.<br>&#xA0;&#xA0; */ <br>&#xA0; </span><span class="keyword">public static function </span><span class="default">compare</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">)<br>&#xA0; {<br>&#xA0; &#xA0; if(</span><span class="default">$a</span><span class="keyword">-&gt;</span><span class="default">name </span><span class="keyword">&lt; </span><span class="default">$b</span><span class="keyword">-&gt;</span><span class="default">name</span><span class="keyword">) return -</span><span class="default">1</span><span class="keyword">;<br>&#xA0; &#xA0; else if(</span><span class="default">$a</span><span class="keyword">-&gt;</span><span class="default">name </span><span class="keyword">== </span><span class="default">$b</span><span class="keyword">-&gt;</span><span class="default">name</span><span class="keyword">) return </span><span class="default">0</span><span class="keyword">;<br>&#xA0; &#xA0; else return </span><span class="default">1</span><span class="keyword">;<br>&#xA0; }<br><br>&#xA0; </span><span class="comment">/*<br>&#xA0;&#xA0; * a String representation for all Animals.<br>&#xA0;&#xA0; */<br>&#xA0; </span><span class="keyword">public function </span><span class="default">__toString</span><span class="keyword">()<br>&#xA0; {<br>&#xA0; &#xA0; return </span><span class="string">&quot;</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">name</span><span class="string"> the </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">type</span><span class="string"> goes </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">sound</span><span class="string">&quot;</span><span class="keyword">;<br>&#xA0; }<br>}<br><br></span><span class="default">?&gt;<br></span><br>Trying to instantiate an object of type Animal will not work...<br><br>$myPet = new Animal(&quot;Parrot&quot;, &quot;Captain Jack&quot;, &quot;Kaaawww!&quot;); // throws Fatal Error: cannot instantiate abstract class Animal.<br><br>Declaring Animal as abstract is like killing two birds with one stone. 1. We stop it from being instantiated - which means we do not need a private __construct() or a static getInstance() method, and 2. We can use it for polymorphic behavior. In our case here, that means &quot;__construct&quot;, &quot;__toString&quot; and &quot;compare&quot; will be called for all subclasses of Animal that have not defined their own implementations.<br><br>The following subclasses use parent::__construct(), which sends all new data to Animal. Our Animal class stores this data and defines functions for polymorphism to work... and the best part is, it keeps our subclass defs super short and even sweeter.<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">class </span><span class="default">Dog </span><span class="keyword">extends </span><span class="default">Animal</span><span class="keyword">{<br>&#xA0; public function </span><span class="default">__construct</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">){<br>&#xA0; &#xA0; </span><span class="default">parent</span><span class="keyword">::</span><span class="default">__construct</span><span class="keyword">(</span><span class="string">&quot;Dog&quot;</span><span class="keyword">, </span><span class="default">$name</span><span class="keyword">, </span><span class="string">&quot;woof!&quot;</span><span class="keyword">);<br>&#xA0; }<br>}<br><br>class </span><span class="default">Cat </span><span class="keyword">extends </span><span class="default">Animal</span><span class="keyword">{<br>&#xA0; public function </span><span class="default">__construct</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">){<br>&#xA0; &#xA0; </span><span class="default">parent</span><span class="keyword">::</span><span class="default">__construct</span><span class="keyword">(</span><span class="string">&quot;Cat&quot;</span><span class="keyword">, </span><span class="default">$name</span><span class="keyword">, </span><span class="string">&quot;meeoow!&quot;</span><span class="keyword">);<br>&#xA0; }<br>}<br><br>class </span><span class="default">Bird </span><span class="keyword">extends </span><span class="default">Animal</span><span class="keyword">{<br>&#xA0; public function </span><span class="default">__construct</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">){<br>&#xA0; &#xA0; </span><span class="default">parent</span><span class="keyword">::</span><span class="default">__construct</span><span class="keyword">(</span><span class="string">&quot;Bird&quot;</span><span class="keyword">, </span><span class="default">$name</span><span class="keyword">, </span><span class="string">&quot;chirp chirp!!&quot;</span><span class="keyword">);<br>&#xA0; }<br>}<br><br></span><span class="comment"># create a PHP Array and initialize it with Animal objects<br></span><span class="default">$animals </span><span class="keyword">= array(<br>&#xA0; new </span><span class="default">Dog</span><span class="keyword">(</span><span class="string">&quot;Fido&quot;</span><span class="keyword">),<br>&#xA0; new </span><span class="default">Bird</span><span class="keyword">(</span><span class="string">&quot;Celeste&quot;</span><span class="keyword">),<br>&#xA0; new </span><span class="default">Cat</span><span class="keyword">(</span><span class="string">&quot;Pussy&quot;</span><span class="keyword">),<br>&#xA0; new </span><span class="default">Dog</span><span class="keyword">(</span><span class="string">&quot;Brad&quot;</span><span class="keyword">),<br>&#xA0; new </span><span class="default">Bird</span><span class="keyword">(</span><span class="string">&quot;Kiki&quot;</span><span class="keyword">),<br>&#xA0; new </span><span class="default">Cat</span><span class="keyword">(</span><span class="string">&quot;Abraham&quot;</span><span class="keyword">),<br>&#xA0; new </span><span class="default">Dog</span><span class="keyword">(</span><span class="string">&quot;Jawbone&quot;</span><span class="keyword">)<br>);<br><br></span><span class="comment"># sort $animals with PHP&apos;s usort - calls Animal::compare() many many times.<br></span><span class="default">usort</span><span class="keyword">(</span><span class="default">$animals</span><span class="keyword">, array(</span><span class="string">&quot;Animal&quot;</span><span class="keyword">, </span><span class="string">&quot;compare&quot;</span><span class="keyword">));<br><br></span><span class="comment"># print out the sorted results - calls Animal-&gt;__toString().<br></span><span class="keyword">foreach(</span><span class="default">$animals </span><span class="keyword">as </span><span class="default">$animal</span><span class="keyword">) echo </span><span class="string">&quot;</span><span class="default">$animal</span><span class="string">&lt;br&gt;\n&quot;</span><span class="keyword">;<br><br></span><span class="default">?&gt;<br></span><br>The results are &quot;sorted by name&quot; and &quot;printed&quot; by the Animal class:<br><br>Abraham the Cat goes meeoow!<br>Brad the Dog goes woof!<br>Celeste the Bird goes chirp chirp!!<br>Fido the Dog goes woof!<br>Jawbone the Dog goes woof!<br>Kiki the Bird goes chirp chirp!!<br>Pussy the Cat goes meeoow!<br><br>Using parent::__construct() in a subclass and a super smart base class, gives your child objects a headstart in life, by alleviating them from having to define or handle several error and exception routines that they have no control over.<br><br>Notice how subclass definitions are really short - no variables or functions at all, and there is no private __construct() method anywhere? Notice how objects of type Dog, Cat, and Bird are all sorted by our base class Animal? All the class definitions above address several issues (keeping objects from being instantiated) and enforces the desired, consistent, and reliable behavior everytime... with the least amount of code. In addition, new extenstions can easily be created. Each subclass is now super easy to redefine or even extend... now that you can see a way to do it.</span>
</div>
  

#


<div class="phpcode"><span class="html">
Correction to the previous poster about non public constructors. If I wanted to implement Singleton design pattern where I would only want one instance of the class I would want to prevent instantiation of the class from outside of the class by making the constructor private. An example follows:<br><br>class Foo {<br><br>&#xA0; private static $instance;<br><br>&#xA0; private __construct() {<br>&#xA0; &#xA0; // Do stuff<br>&#xA0; }<br><br>&#xA0; public static getInstance() {<br><br>&#xA0; &#xA0; if (!isset(self::$instance)) {<br>&#xA0; &#xA0; &#xA0; $c = __CLASS__;<br>&#xA0; &#xA0; &#xA0; $instance = new $c;<br>&#xA0; &#xA0; }<br><br>&#xA0; &#xA0; return self::$instance;<br>&#xA0; }<br><br>&#xA0; public function sayHello() {<br>&#xA0; &#xA0; echo &quot;Hello World!!&quot;;<br>&#xA0; }<br><br>}<br><br>$bar = Foo::getInstance();<br><br>// Prints &apos;Hello World&apos; on the screen.<br>$bar -&gt; sayHello();</span>
</div>
  

#


<div class="phpcode"><span class="html">
It&apos;s always the easy things that get you -<br><br>Being new to OOP, it took me quite a while to figure out that there are TWO underscores in front of the word __construct.<br><br>It is __construct<br>Not _construct<br><br>Extremely obvious once you figure it out, but it can be sooo frustrating until you do.<br><br>I spent quite a bit of needless time debugging working code.<br><br>I even thought about it a few times, thinking it looked a little long in the examples, but at the time that just seemed silly(always thinking &quot;oh somebody would have made that clear if it weren&apos;t just a regular underscore...&quot;)<br><br>All the manuals I looked at, all the tuturials I read, all the examples I browsed through&#xA0; - not once did anybody mention this!&#xA0; <br><br>(please don&apos;t tell me it&apos;s explained somewhere on this page and I just missed it,&#xA0; you&apos;ll only add to my pain.)<br><br>I hope this helps somebody else!</span>
</div>
  

#

[Official documentation page](https://www.php.net/manual/en/language.oop5.decon.php)

**[To root](/README.md)**