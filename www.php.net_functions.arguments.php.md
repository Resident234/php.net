# Function arguments




<div class="phpcode"><span class="html">
To experiment on performance of pass-by-reference and pass-by-value, I used this&#xA0; script. Conclusions are below. <br><br>#!/usr/bin/php<br><span class="default">&lt;?php<br></span><span class="keyword">function </span><span class="default">sum</span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">,</span><span class="default">$max</span><span class="keyword">){&#xA0;&#xA0; </span><span class="comment">//For Reference, use:&#xA0; &quot;&amp;$array&quot;<br>&#xA0; &#xA0; </span><span class="default">$sum</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;<br>&#xA0; &#xA0; for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">2</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++){<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="comment">#$array[$i]++;&#xA0; &#xA0; &#xA0; &#xA0; //Uncomment this line to modify the array within the function.<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$sum </span><span class="keyword">+= </span><span class="default">$array</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">];&#xA0; <br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; return (</span><span class="default">$sum</span><span class="keyword">);<br>}<br><br></span><span class="default">$max </span><span class="keyword">= </span><span class="default">1E7&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="comment">//10 M data points.<br></span><span class="default">$data </span><span class="keyword">= </span><span class="default">range</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">,</span><span class="default">$max</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">);<br><br></span><span class="default">$start </span><span class="keyword">= </span><span class="default">microtime</span><span class="keyword">(</span><span class="default">true</span><span class="keyword">);<br>for (</span><span class="default">$x </span><span class="keyword">= </span><span class="default">0 </span><span class="keyword">; </span><span class="default">$x </span><span class="keyword">&lt; </span><span class="default">100</span><span class="keyword">; </span><span class="default">$x</span><span class="keyword">++){<br>&#xA0; &#xA0; </span><span class="default">$sum </span><span class="keyword">= </span><span class="default">sum</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">, </span><span class="default">$max</span><span class="keyword">);<br>}<br></span><span class="default">$end </span><span class="keyword">=&#xA0; </span><span class="default">microtime</span><span class="keyword">(</span><span class="default">true</span><span class="keyword">);<br>echo </span><span class="string">&quot;Time: &quot;</span><span class="keyword">.(</span><span class="default">$end </span><span class="keyword">- </span><span class="default">$start</span><span class="keyword">).</span><span class="string">&quot; s\n&quot;</span><span class="keyword">;<br><br></span><span class="comment">/* Run times:<br>#&#xA0; &#xA0; PASS BY&#xA0; &#xA0; MODIFIED?&#xA0;&#xA0; Time<br>-&#xA0; &#xA0; -------&#xA0; &#xA0; ---------&#xA0;&#xA0; ----<br>1&#xA0; &#xA0; value&#xA0; &#xA0; &#xA0; no&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; 56 us<br>2&#xA0; &#xA0; reference&#xA0; no&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; 58 us<br><br>3&#xA0; &#xA0; valuue&#xA0; &#xA0;&#xA0; yes&#xA0; &#xA0; &#xA0; &#xA0;&#xA0; 129 s<br>4&#xA0; &#xA0; reference&#xA0; yes&#xA0; &#xA0; &#xA0; &#xA0;&#xA0; 66 us<br><br>Conclusions:<br><br>1. PHP is already smart about zero-copy / copy-on-write. A function call does NOT copy the data unless it needs to; the data is<br>&#xA0;&#xA0; only copied on write. That&apos;s why&#xA0; #1 and #2 take similar times, whereas #3 takes 2 million times longer than #4.<br>&#xA0;&#xA0; [You never need to use &amp;$array to ask the compiler to do a zero-copy optimisation; it can work that out for itself.]<br><br>2. You do use &amp;$array&#xA0; to tell the compiler &quot;it is OK for the function to over-write my argument in place, I don&apos;t need the original<br>&#xA0;&#xA0; any more.&quot; This can make a huge difference to performance when we have large amounts of memory to copy.<br>&#xA0;&#xA0; (This is the only way it is done in C, arrays are always passed as pointers)<br><br>3. The other use of &amp; is as a way to specify where data should be *returned*. (e.g. as used by exec() ).<br>&#xA0;&#xA0; (This is a C-like way of passing pointers for outputs, whereas PHP functions normally return complex types, or multiple answers<br>&#xA0;&#xA0; in an array)<br><br>4. It&apos;s&#xA0; unhelpful that only the function definition has &amp;. The caller should have it, at least as syntactic sugar. Otherwise<br>&#xA0;&#xA0; it leads to unreadable code: because the person reading the function call doesn&apos;t expect it to pass by reference. At the moment,<br>&#xA0;&#xA0; it&apos;s necessary to write a by-reference function call with a comment, thus:<br>&#xA0; &#xA0; $sum = sum($data,$max);&#xA0; //warning, $data passed by reference, and may be modified.<br><br>5. Sometimes, pass by reference could be at the choice of the caller, NOT the function definitition. PHP doesn&apos;t allow it, but it<br>&#xA0;&#xA0; would be meaningful for the caller to decide to pass data in as a reference. i.e. &quot;I&apos;m done with the variable, it&apos;s OK to stomp<br>&#xA0;&#xA0; on it in memory&quot;.<br>*/<br></span><span class="default">?&gt;</span>
</span>
</div>
  

#


<div class="phpcode"><span class="html">
A function&apos;s argument that is an object, will have its properties modified by the function although you don&apos;t need to pass it by reference.<br><br><span class="default">&lt;?php<br>$x </span><span class="keyword">= new </span><span class="default">stdClass</span><span class="keyword">();<br></span><span class="default">$x</span><span class="keyword">-&gt;</span><span class="default">prop </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br><br>function </span><span class="default">f </span><span class="keyword">( </span><span class="default">$o </span><span class="keyword">) </span><span class="comment">// Notice the absence of &amp;<br></span><span class="keyword">{<br>&#xA0; </span><span class="default">$o</span><span class="keyword">-&gt;</span><span class="default">prop </span><span class="keyword">++;<br>}<br><br></span><span class="default">f</span><span class="keyword">(</span><span class="default">$x</span><span class="keyword">);<br><br>echo </span><span class="default">$x</span><span class="keyword">-&gt;</span><span class="default">prop</span><span class="keyword">; </span><span class="comment">// shows: 2<br></span><span class="default">?&gt;<br></span><br>This is different for arrays:<br><br><span class="default">&lt;?php<br>$y </span><span class="keyword">= [ </span><span class="string">&apos;prop&apos; </span><span class="keyword">=&gt; </span><span class="default">1 </span><span class="keyword">];<br><br>function </span><span class="default">g</span><span class="keyword">( </span><span class="default">$a </span><span class="keyword">)<br>{<br>&#xA0; </span><span class="default">$a</span><span class="keyword">[</span><span class="string">&apos;prop&apos;</span><span class="keyword">] ++;<br>&#xA0; echo </span><span class="default">$a</span><span class="keyword">[</span><span class="string">&apos;prop&apos;</span><span class="keyword">];&#xA0; </span><span class="comment">// shows: 2<br></span><span class="keyword">}<br><br></span><span class="default">g</span><span class="keyword">(</span><span class="default">$y</span><span class="keyword">);<br><br>echo </span><span class="default">$y</span><span class="keyword">[</span><span class="string">&apos;prop&apos;</span><span class="keyword">];&#xA0; </span><span class="comment">// shows: 1<br></span><span class="default">?&gt;</span>
</span>
</div>
  

#


<div class="phpcode"><span class="html">
In function calls, PHP clearly distinguishes between missing arguments and present but empty arguments.&#xA0; Thus:<br><br><span class="default">&lt;?php<br></span><span class="keyword">function </span><span class="default">f</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">= </span><span class="default">4 </span><span class="keyword">) { echo </span><span class="default">$x </span><span class="keyword">. </span><span class="string">&quot;\\n&quot;</span><span class="keyword">; }<br></span><span class="default">f</span><span class="keyword">(); </span><span class="comment">// prints 4<br></span><span class="default">f</span><span class="keyword">( </span><span class="default">null </span><span class="keyword">); </span><span class="comment">// prints blank line<br></span><span class="default">f</span><span class="keyword">( </span><span class="default">$y </span><span class="keyword">); </span><span class="comment">// $y undefined, prints blank line<br></span><span class="default">?&gt;<br></span><br>The utility of the optional argument feature is thus somewhat diminished.&#xA0; Suppose you want to call the function f many times from function g, allowing the caller of g to specify if f should be called with a specific value or with its default value:<br><br><span class="default">&lt;?php<br></span><span class="keyword">function </span><span class="default">f</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">= </span><span class="default">4 </span><span class="keyword">) {echo </span><span class="default">$x </span><span class="keyword">. </span><span class="string">&quot;\\n&quot;</span><span class="keyword">; }<br><br></span><span class="comment">// option 1: cut and paste the default value from f&apos;s interface into g&apos;s<br></span><span class="keyword">function </span><span class="default">g</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">= </span><span class="default">4 </span><span class="keyword">) { </span><span class="default">f</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">); </span><span class="default">f</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">); }<br><br></span><span class="comment">// option 2: branch based on input to g<br></span><span class="keyword">function </span><span class="default">g</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">= </span><span class="default">null </span><span class="keyword">) { if ( !isset( </span><span class="default">$x </span><span class="keyword">) ) { </span><span class="default">f</span><span class="keyword">(); </span><span class="default">f</span><span class="keyword">() } else { </span><span class="default">f</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">); </span><span class="default">f</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">); } }<br></span><span class="default">?&gt;<br></span><br>Both options suck.<br><br>The best approach, it seems to me, is to always use a sentinel like null as the default value of an optional argument.&#xA0; This way, callers like g and g&apos;s clients have many options, and furthermore, callers always know how to omit arguments so they can omit one in the middle of the parameter list.<br><br><span class="default">&lt;?php<br></span><span class="keyword">function </span><span class="default">f</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">= </span><span class="default">null </span><span class="keyword">) { if ( !isset( </span><span class="default">$x </span><span class="keyword">) ) </span><span class="default">$x </span><span class="keyword">= </span><span class="default">4</span><span class="keyword">; echo </span><span class="default">$x </span><span class="keyword">. </span><span class="string">&quot;\\n&quot;</span><span class="keyword">; }<br><br>function </span><span class="default">g</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">= </span><span class="default">null </span><span class="keyword">) { </span><span class="default">f</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">); </span><span class="default">f</span><span class="keyword">( </span><span class="default">$x </span><span class="keyword">); }<br><br></span><span class="default">f</span><span class="keyword">(); </span><span class="comment">// prints 4<br></span><span class="default">f</span><span class="keyword">( </span><span class="default">null </span><span class="keyword">); </span><span class="comment">// prints 4<br></span><span class="default">f</span><span class="keyword">( </span><span class="default">$y </span><span class="keyword">); </span><span class="comment">// $y undefined, prints 4<br></span><span class="default">g</span><span class="keyword">(); </span><span class="comment">// prints 4 twice<br></span><span class="default">g</span><span class="keyword">( </span><span class="default">null </span><span class="keyword">); </span><span class="comment">// prints 4 twice<br></span><span class="default">g</span><span class="keyword">( </span><span class="default">5 </span><span class="keyword">); </span><span class="comment">// prints 5 twice<br><br></span><span class="default">?&gt;</span>
</span>
</div>
  

#


<div class="phpcode"><span class="html">
PASSING A &quot;VARIABLE-LENGTH ARGUMENT LIST OF REFERENCES&quot; TO A FUNCTION<br>As of PHP 5, Call-time pass-by-reference has been deprecated, this represents no problem in most cases, since instead of calling a function like this:<br>&#xA0;&#xA0; myfunction($arg1, &amp;$arg2, &amp;$arg3);<br><br>you can call it<br>&#xA0;&#xA0; myfunction($arg1, $arg2, $arg3);<br><br>provided you have defined your function as <br>&#xA0;&#xA0; function myfuncion($a1, &amp;$a2, &amp;$a3) { // so &amp;$a2 and &amp;$a3 are <br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;&#xA0; // declared to be refs.<br>&#xA0; &#xA0; ... &lt;function-code&gt;<br>&#xA0;&#xA0; }<br><br>However, what happens if you wanted to pass an undefined number of references, i.e., something like:<br>&#xA0;&#xA0; myfunction(&amp;$arg1, &amp;$arg2, ..., &amp;$arg-n);?<br>This doesn&apos;t work in PHP 5 anymore.<br><br>In the following code I tried to amend this by using the <br>array() language-construct as the actual argument in the <br>call to the function.<br><br><span class="default">&lt;?php<br><br>&#xA0; </span><span class="keyword">function </span><span class="default">aa </span><span class="keyword">(</span><span class="default">$A</span><span class="keyword">) {<br>&#xA0; &#xA0; </span><span class="comment">// This function increments each <br>&#xA0; &#xA0; // &quot;pseudo-argument&quot; by 2s<br>&#xA0; &#xA0; </span><span class="keyword">foreach (</span><span class="default">$A </span><span class="keyword">as &amp;</span><span class="default">$x</span><span class="keyword">) { <br>&#xA0; &#xA0; &#xA0; </span><span class="default">$x </span><span class="keyword">+= </span><span class="default">2</span><span class="keyword">;<br>&#xA0; &#xA0; }<br>&#xA0; }<br> <br>&#xA0; </span><span class="default">$x </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="default">$y </span><span class="keyword">= </span><span class="default">2</span><span class="keyword">; </span><span class="default">$z </span><span class="keyword">= </span><span class="default">3</span><span class="keyword">;<br>&#xA0; <br>&#xA0; </span><span class="default">aa</span><span class="keyword">(array(&amp;</span><span class="default">$x</span><span class="keyword">, &amp;</span><span class="default">$y</span><span class="keyword">, &amp;</span><span class="default">$z</span><span class="keyword">));<br>&#xA0; echo </span><span class="string">&quot;--</span><span class="default">$x</span><span class="string">--</span><span class="default">$y</span><span class="string">--</span><span class="default">$z</span><span class="string">--\n&quot;</span><span class="keyword">;<br>&#xA0; </span><span class="comment">// This will output:<br>&#xA0; // --3--4--5--<br></span><span class="default">?&gt;<br></span><br>I hope this is useful.<br><br>Sergio.</span>
</div>
  

#


<div class="phpcode"><span class="html">
You can use (very) limited signatures for your functions, specifing type of arguments allowed. <br><br>For example:<br><br>public function Right( My_Class $a, array $b )<br><br>tells first argument have to by object of My_Class, second an array. My_Class means that you can pass also object of class that either extends My_Class or implements (if My_Class is abstract class) My_Class. If you need exactly My_Class you need to either make it final, or add some code to check what $a really.<br><br>Also note, that (unfortunately) &quot;array&quot; is the only built-in type you can use in signature. Any other types i.e.:<br><br>public function Wrong( string $a, boolean $b )<br><br>will cause an error, because PHP will complain that $a is not an *object* of class string (and $b is not an object of class boolean).<br><br>So if you need to know if $a is a string or $b bool, you need to write some code in your function body and i.e. throw exception if you detect type mismatch (or you can try to cast if it&apos;s doable).</span>
</div>
  

#


<div class="phpcode"><span class="html">
There is a nice trick to emulate variables/function calls/etc as default values:<br><br><span class="default">&lt;?php<br>$myVar </span><span class="keyword">= </span><span class="string">&quot;Using a variable as a default value!&quot;</span><span class="keyword">;<br><br>function </span><span class="default">myFunction</span><span class="keyword">(</span><span class="default">$myArgument</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">) {<br>&#xA0; &#xA0; if(</span><span class="default">$myArgument</span><span class="keyword">===</span><span class="default">null</span><span class="keyword">)<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$myArgument </span><span class="keyword">= </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="string">&quot;myVar&quot;</span><span class="keyword">];<br>&#xA0; &#xA0; echo </span><span class="default">$myArgument</span><span class="keyword">;<br>}<br><br></span><span class="comment">// Outputs &quot;Hello World!&quot;:<br></span><span class="default">myFunction</span><span class="keyword">(</span><span class="string">&quot;Hello World!&quot;</span><span class="keyword">);<br></span><span class="comment">// Outputs &quot;Using a variable as a default value!&quot;:<br></span><span class="default">myFunction</span><span class="keyword">();<br></span><span class="comment">// Outputs the same again:<br></span><span class="default">myFunction</span><span class="keyword">(</span><span class="default">null</span><span class="keyword">);<br></span><span class="comment">// Outputs &quot;Changing the variable affects the function!&quot;:<br></span><span class="default">$myVar </span><span class="keyword">= </span><span class="string">&quot;Changing the variable affects the function!&quot;</span><span class="keyword">;<br></span><span class="default">myFunction</span><span class="keyword">();<br></span><span class="default">?&gt;<br></span>In general, you define the default value as null (or whatever constant you like), and then check for that value at the start of the function, computing the actual default if needed, before using the argument for actual work.<br>Building upon this, it&apos;s also easy to provide fallback behaviors when the argument given is not valid: simply put a default that is known to be invalid in the prototype, and then check for general validity instead of a specific value: if the argument is not valid (either not given, so the default is used, or an invalid value was given), the function computes a (valid) default to use.</span>
</div>
  

#

[Official documentation page](https://www.php.net/manual/en/functions.arguments.php)

**[To root](/)**