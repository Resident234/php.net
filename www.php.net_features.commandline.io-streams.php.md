# Input/output streams




<div class="phpcode"><span class="html">
The command line interface data in STDIN is not made available until return is pressed.<br>By adding &quot;readline_callback_handler_install(&apos;&apos;, function(){});&quot; before reading STDIN for the first time single key presses can be captured. <br><br>Note: This only seems to work under Linux CLI and will not work in Apache or Windows CLI.<br><br>This cam be used to obscure a password or used with &apos;stream_select&apos; to make a non blocking keyboard monitor.<br><br><span class="default">&lt;?php<br><br></span><span class="comment">// Demo WITHOUT readline_callback_handler_install(&apos;&apos;, function(){});<br>&#xA0; &#xA0; </span><span class="default">$resSTDIN</span><span class="keyword">=</span><span class="default">fopen</span><span class="keyword">(</span><span class="string">&quot;php://stdin&quot;</span><span class="keyword">,</span><span class="string">&quot;r&quot;</span><span class="keyword">);<br>&#xA0; &#xA0; echo(</span><span class="string">&quot;Type &apos;x&apos;. Then press return.&quot;</span><span class="keyword">);<br>&#xA0; &#xA0; </span><span class="default">$strChar </span><span class="keyword">= </span><span class="default">stream_get_contents</span><span class="keyword">(</span><span class="default">$resSTDIN</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">);<br><br>&#xA0; &#xA0; echo(</span><span class="string">&quot;\nYou typed: &quot;</span><span class="keyword">.</span><span class="default">$strChar</span><span class="keyword">.</span><span class="string">&quot;\n\n&quot;</span><span class="keyword">);<br>&#xA0; &#xA0; </span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$resSTDIN</span><span class="keyword">);<br>&#xA0; &#xA0; <br></span><span class="comment">// Demo WITH readline_callback_handler_install(&apos;&apos;, function(){});<br>// This line removes the wait for &lt;CR&gt; on STDIN<br>&#xA0; &#xA0; </span><span class="default">readline_callback_handler_install</span><span class="keyword">(</span><span class="string">&apos;&apos;</span><span class="keyword">, function(){});<br>&#xA0; &#xA0; <br>&#xA0; &#xA0; </span><span class="default">$resSTDIN</span><span class="keyword">=</span><span class="default">fopen</span><span class="keyword">(</span><span class="string">&quot;php://stdin&quot;</span><span class="keyword">,</span><span class="string">&quot;r&quot;</span><span class="keyword">);<br>&#xA0; &#xA0; echo(</span><span class="string">&quot;We have now run: readline_callback_handler_install(&apos;&apos;, function(){});\n&quot;</span><span class="keyword">);<br>&#xA0; &#xA0; echo(</span><span class="string">&quot;Press the &apos;y&apos; key&quot;</span><span class="keyword">);<br>&#xA0; &#xA0; </span><span class="default">$strChar </span><span class="keyword">= </span><span class="default">stream_get_contents</span><span class="keyword">(</span><span class="default">$resSTDIN</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">);<br>&#xA0; &#xA0; echo(</span><span class="string">&quot;\nYou pressed: &quot;</span><span class="keyword">.</span><span class="default">$strChar</span><span class="keyword">.</span><span class="string">&quot;\nBut did not have to press &lt;cr&gt;\n&quot;</span><span class="keyword">);<br>&#xA0; &#xA0; </span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$resSTDIN</span><span class="keyword">);<br>&#xA0; &#xA0; </span><span class="default">readline_callback_handler_remove </span><span class="keyword">();<br>&#xA0; &#xA0; echo(</span><span class="string">&quot;\nGoodbye\n&quot;</span><span class="keyword">)<br></span><span class="default">?&gt;<br></span><br>It also hides text from the CLI so can be used for things like. password obscurification. <br>eg<br><br><span class="default">&lt;?php<br>&#xA0; &#xA0; readline_callback_handler_install</span><span class="keyword">(</span><span class="string">&apos;&apos;</span><span class="keyword">, function(){});<br>&#xA0; &#xA0; echo(</span><span class="string">&quot;Enter password followed by return. (Do not use a real one!)\n&quot;</span><span class="keyword">);<br>&#xA0; &#xA0; echo(</span><span class="string">&quot;Password: &quot;</span><span class="keyword">);<br>&#xA0; &#xA0; </span><span class="default">$strObscured</span><span class="keyword">=</span><span class="string">&apos;&apos;</span><span class="keyword">;<br>&#xA0; &#xA0; while(</span><span class="default">true</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; </span><span class="default">$strChar </span><span class="keyword">= </span><span class="default">stream_get_contents</span><span class="keyword">(</span><span class="default">STDIN</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">);<br>&#xA0; &#xA0; if(</span><span class="default">$strChar</span><span class="keyword">===</span><span class="default">chr</span><span class="keyword">(</span><span class="default">10</span><span class="keyword">))<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; break;<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; </span><span class="default">$strObscured</span><span class="keyword">.=</span><span class="default">$strChar</span><span class="keyword">;<br>&#xA0; &#xA0; echo(</span><span class="string">&quot;*&quot;</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; echo(</span><span class="string">&quot;\n&quot;</span><span class="keyword">);<br>&#xA0; &#xA0; echo(</span><span class="string">&quot;You entered: &quot;</span><span class="keyword">.</span><span class="default">$strObscured</span><span class="keyword">.</span><span class="string">&quot;\n&quot;</span><span class="keyword">);<br></span><span class="default">?&gt;</span>
</span>
</div>
  

#


<div class="phpcode"><span class="html">
Please remember in multi-process applications (which are best suited under CLI), that I/O operations often will BLOCK signals from being processed.<br><br>For instance, if you have a parent waiting on fread(STDIN), it won&apos;t handle SIGCHLD, even if you defined a signal handler for it, until after the call to fread has returned. <br><br>Your solution in this case is to wait on stream_select() to find out whether reading will block. Waiting on stream_select(), critically, does NOT BLOCK signals from being processed. <br><br>Aurelien</span>
</div>
  

#


<div class="phpcode"><span class="html">
The following code shows how to test for input on STDIN.&#xA0; In this case, we were looking for CSV data, so we use fgetcsv to read STDIN, if it creates an array, we assume CVS input on STDIN, if no array was created, we assume there&apos;s no input from STDIN, and look, later, to an argument with a CSV file name.<br><br>Note, without the stream_set_blocking() call, fgetcsv() hangs on STDIN, awaiting input from the user, which isn&apos;t useful as we&apos;re looking for a piped file. If it isn&apos;t here already, it isn&apos;t going to be.<br><br><span class="default">&lt;?php<br>stream_set_blocking</span><span class="keyword">(</span><span class="default">STDIN</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">);<br></span><span class="default">$csv_ar </span><span class="keyword">= </span><span class="default">fgetcsv</span><span class="keyword">(</span><span class="default">STDIN</span><span class="keyword">);<br>if (</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$csv_ar</span><span class="keyword">)){<br>&#xA0; print </span><span class="string">&quot;CVS on STDIN\n&quot;</span><span class="keyword">;<br>} else {<br>&#xA0; print </span><span class="string">&quot;Look to ARGV for CSV file name.\n&quot;</span><span class="keyword">;<br>}<br></span><span class="default">?&gt;</span>
</span>
</div>
  

#

[Official documentation page](https://www.php.net/manual/en/features.commandline.io-streams.php)

**[â¬† to root](/)**