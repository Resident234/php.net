# mysqli::real_escape_string




<div class="phpcode"><span class="html">
Note, that if no connection is open, mysqli_real_escape_string() will return an empty string!</span>
</div>
  

#


<div class="phpcode"><span class="html">
For percent sign and underscore I use this:<br><span class="default">&lt;?php<br>$more_escaped </span><span class="keyword">= </span><span class="default">addcslashes</span><span class="keyword">(</span><span class="default">$escaped</span><span class="keyword">, </span><span class="string">&apos;%_&apos;</span><span class="keyword">);<br></span><span class="default">?&gt;</span>
</span>
</div>
  

#


<div class="phpcode"><span class="html">
Presenting several UTF-8 / Multibyte-aware escape functions.<br><br>These functions represent alternatives to mysqli::real_escape_string, as long as your DB connection and Multibyte extension are using the same character set (UTF-8), they will produce the same results by escaping the same characters as mysqli::real_escape_string.<br><br>This is based on research I did for my SQL Query Builder class:<br><a href="https://github.com/twister-php/sql" rel="nofollow" target="_blank">https://github.com/twister-php/sql</a><br><br><span class="default">&lt;?php<br></span><span class="comment">/**<br> * Returns a string with backslashes before characters that need to be escaped.<br> * As required by MySQL and suitable for multi-byte character sets<br> * Characters encoded are NUL (ASCII 0), \n, \r, \, &apos;, &quot;, and ctrl-Z.<br> *<br> * @param string $string String to add slashes to<br> * @return $string with `\` prepended to reserved characters <br> *<br> * @author Trevor Herselman<br> */<br></span><span class="keyword">if (</span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">&apos;mb_ereg_replace&apos;</span><span class="keyword">))<br>{<br>&#xA0; &#xA0; function </span><span class="default">mb_escape</span><span class="keyword">(</span><span class="default">string $string</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; return </span><span class="default">mb_ereg_replace</span><span class="keyword">(</span><span class="string">&apos;[\x00\x0A\x0D\x1A\x22\x27\x5C]&apos;</span><span class="keyword">, </span><span class="string">&apos;\\\0&apos;</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>} else {<br>&#xA0; &#xA0; function </span><span class="default">mb_escape</span><span class="keyword">(</span><span class="default">string $string</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; return </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">&apos;~[\x00\x0A\x0D\x1A\x22\x27\x5C]~u&apos;</span><span class="keyword">, </span><span class="string">&apos;\\\$0&apos;</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>}<br><br></span><span class="default">?&gt;<br></span><br>Characters escaped are (the same as mysqli::real_escape_string):<br><br>00 = \0 (NUL)<br>0A = \n<br>0D = \r<br>1A = ctl-Z<br>22 = &quot;<br>27 = &apos;<br>5C = \<br><br>Note: preg_replace() is in PCRE_UTF8 (UTF-8) mode (`u`).<br><br>Enhanced version:<br><br>When escaping strings for `LIKE` syntax, remember that you also need to escape the special characters _ and %<br><br>So this is a more fail-safe version (even when compared to mysqli::real_escape_string, because % characters in user input can cause unexpected results and even security violations via SQL injection in LIKE statements):<br><br><span class="default">&lt;?php<br><br></span><span class="comment">/**<br> * Returns a string with backslashes before characters that need to be escaped.<br> * As required by MySQL and suitable for multi-byte character sets<br> * Characters encoded are NUL (ASCII 0), \n, \r, \, &apos;, &quot;, and ctrl-Z.<br> * In addition, the special control characters % and _ are also escaped,<br> * suitable for all statements, but especially suitable for `LIKE`.<br> *<br> * @param string $string String to add slashes to<br> * @return $string with `\` prepended to reserved characters <br> *<br> * @author Trevor Herselman<br> */<br></span><span class="keyword">if (</span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">&apos;mb_ereg_replace&apos;</span><span class="keyword">))<br>{<br>&#xA0; &#xA0; function </span><span class="default">mb_escape</span><span class="keyword">(</span><span class="default">string $string</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; return </span><span class="default">mb_ereg_replace</span><span class="keyword">(</span><span class="string">&apos;[\x00\x0A\x0D\x1A\x22\x25\x27\x5C\x5F]&apos;</span><span class="keyword">, </span><span class="string">&apos;\\\0&apos;</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>} else {<br>&#xA0; &#xA0; function </span><span class="default">mb_escape</span><span class="keyword">(</span><span class="default">string $string</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; return </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">&apos;~[\x00\x0A\x0D\x1A\x22\x25\x27\x5C\x5F]~u&apos;</span><span class="keyword">, </span><span class="string">&apos;\\\$0&apos;</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>}<br><br></span><span class="default">?&gt;<br></span><br>Additional characters escaped:<br><br>25 = %<br>5F = _<br><br>Bonus function:<br><br>The original MySQL `utf8` character-set (for tables and fields) only supports 3-byte sequences.<br>4-byte characters are not common, but I&apos;ve had queries fail to execute on 4-byte UTF-8 characters, so you should be using `utf8mb4` wherever possible.<br><br>However, if you still want to use `utf8`, you can use the following function to replace all 4-byte sequences.<br><br><span class="default">&lt;?php<br></span><span class="comment">// Modified from: <a href="https://stackoverflow.com/a/24672780/2726557" rel="nofollow" target="_blank">https://stackoverflow.com/a/24672780/2726557</a><br></span><span class="keyword">function </span><span class="default">mysql_utf8_sanitizer</span><span class="keyword">(</span><span class="default">string $str</span><span class="keyword">)<br>{<br>&#xA0; &#xA0; return </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">&apos;/[\x{10000}-\x{10FFFF}]/u&apos;</span><span class="keyword">, </span><span class="string">&quot;\xEF\xBF\xBD&quot;</span><span class="keyword">, </span><span class="default">$str</span><span class="keyword">);<br>}<br></span><span class="default">?&gt;<br></span><br>Pick your poison and use at your own risk!</span>
</div>
  

#


<div class="phpcode"><span class="html">
You can avoid all character escaping issues (on the PHP side) if you use prepare() and bind_param(), as an alternative to placing arbitrary string values in SQL statements.&#xA0; This works because bound parameter values are NOT passed via the SQL statement syntax.</span>
</div>
  

#


<div class="phpcode"><span class="html">
To escape for the purposes of having your queries made successfully, and to prevent SQLi (SQL injection)/stored and/or reflected XSS, it&apos;s a good idea to go with the basics first, then make sure nothing gets in that can be used for SQLi or stored/reflected XSS, or even worse, loading remote images and scripts.<br><br>For example:<br><br><span class="default">&lt;?php<br>&#xA0; &#xA0;&#xA0; <br>&#xA0; &#xA0;&#xA0; </span><span class="comment">// Assume this is a simple comments form with a name and comment.<br><br>&#xA0; &#xA0;&#xA0; </span><span class="default">$name </span><span class="keyword">= </span><span class="default">mysqli_real_escape_string</span><span class="keyword">(</span><span class="default">$conn</span><span class="keyword">, </span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">&apos;name&apos;</span><span class="keyword">]);<br>&#xA0; &#xA0;&#xA0; </span><span class="default">$comments </span><span class="keyword">= </span><span class="default">mysqli_real_escape_string</span><span class="keyword">(</span><span class="default">$conn</span><span class="keyword">, </span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">&apos;comments&apos;</span><span class="keyword">]);<br><br>&#xA0; &#xA0;&#xA0; </span><span class="comment">// Here is where most of the action happens.&#xA0; But see note below<br>&#xA0; &#xA0;&#xA0; // on dumping back out from the database<br><br>&#xA0; &#xA0;&#xA0; // We should use the ENT_QUOTES flag second parameter...<br>&#xA0; &#xA0;&#xA0; </span><span class="default">$name </span><span class="keyword">= </span><span class="default">htmlspecialchars</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">);<br>&#xA0; &#xA0;&#xA0; </span><span class="default">$comments </span><span class="keyword">= </span><span class="default">htmlspecialchars</span><span class="keyword">(</span><span class="default">$comments</span><span class="keyword">);<br><br>&#xA0; &#xA0;&#xA0; </span><span class="default">$insert_sql </span><span class="keyword">= </span><span class="string">&quot;INSERT INTO tbl_comments ( c_id, c_name, c_comments ) VALUES ( DEFAULT, &apos;&quot; </span><span class="keyword">. </span><span class="default">$name </span><span class="keyword">. </span><span class="string">&quot;&apos;, &apos;&quot; </span><span class="keyword">. </span><span class="default">$comments </span><span class="keyword">. </span><span class="string">&quot;&apos;)&quot;</span><span class="keyword">;<br><br>&#xA0; &#xA0;&#xA0; </span><span class="default">$res </span><span class="keyword">= </span><span class="default">mysqli_query</span><span class="keyword">(</span><span class="default">$conn</span><span class="keyword">, </span><span class="default">$insert_sql</span><span class="keyword">);<br>&#xA0; &#xA0;&#xA0; if ( </span><span class="default">$res </span><span class="keyword">=== </span><span class="default">false </span><span class="keyword">) {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="comment">// Something went wrong, handle it<br>&#xA0; &#xA0;&#xA0; </span><span class="keyword">}<br><br>&#xA0; &#xA0;&#xA0; </span><span class="comment">// Now output page showing comments<br></span><span class="default">?&gt;<br></span><br>//&#xA0; Assume we&apos;re in a table with each row containing a name and comment<br><br><span class="default">&lt;?php<br>&#xA0; &#xA0;&#xA0; <br>&#xA0; &#xA0;&#xA0; $res </span><span class="keyword">= </span><span class="default">mysqli_query</span><span class="keyword">(</span><span class="default">$conn</span><span class="keyword">, </span><span class="string">&quot;SELECT c_name, c_comments FROM tbl_comments ORDER BY c_name ASC&quot;</span><span class="keyword">);<br><br>&#xA0; &#xA0;&#xA0; if ( </span><span class="default">$res </span><span class="keyword">=== </span><span class="default">false </span><span class="keyword">)<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="comment">// Something went wrong<br><br>&#xA0; &#xA0;&#xA0; // Or as you like...<br>&#xA0; &#xA0;&#xA0; </span><span class="keyword">while ( </span><span class="default">$row </span><span class="keyword">= </span><span class="default">mysqli_fetch_array</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">, </span><span class="default">MYSQLI_BOTH</span><span class="keyword">) ) {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; <br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="comment">// This will output safe HTML entities if they went in<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; // They will be displayed, but not interpreted<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="keyword">echo </span><span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot; </span><span class="keyword">. </span><span class="default">$row</span><span class="keyword">[</span><span class="string">&apos;c_name&apos;</span><span class="keyword">] . </span><span class="string">&quot;&lt;/td&gt;&quot;</span><span class="keyword">;<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; echo </span><span class="string">&quot;&lt;td&gt;&quot; </span><span class="keyword">. </span><span class="default">$row</span><span class="keyword">[</span><span class="string">&apos;c_comments&apos;</span><span class="keyword">] . </span><span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span><span class="keyword">;<br><br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="comment">// BUT, if you make this mistake...<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="keyword">echo </span><span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot; </span><span class="keyword">. </span><span class="default">htmlspecialchars_decode</span><span class="keyword">(</span><span class="default">$row</span><span class="keyword">[</span><span class="string">&apos;c_name&apos;</span><span class="keyword">]) . </span><span class="string">&quot;&lt;/td&gt;&quot;</span><span class="keyword">;<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; echo </span><span class="string">&quot;&lt;td&gt;&quot; </span><span class="keyword">. </span><span class="default">htmlspecialchars_decode</span><span class="keyword">(</span><span class="default">$row</span><span class="keyword">[</span><span class="string">&apos;c_comments&apos;</span><span class="keyword">]) . </span><span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span><span class="keyword">;<br><br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="comment">// ... then your entities will reflect back as the characters, so<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; // input such as this: &quot;&gt;&lt;img src=x onerror=alert(&apos;xss&apos;)&gt;<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; // will display the &apos;xss&apos; in an alert box in the browser.<br>&#xA0; &#xA0;&#xA0; </span><span class="keyword">}<br><br>&#xA0; &#xA0;&#xA0; </span><span class="default">mysqli_free_result</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">);<br>&#xA0; &#xA0;&#xA0; </span><span class="default">mysqli_close</span><span class="keyword">(</span><span class="default">$conn</span><span class="keyword">);<br></span><span class="default">?&gt;<br></span><br>In most cases, you wouldn&apos;t want to go way overboard sanitizing untrusted user input, for instance:<br><br><span class="default">&lt;?php<br>&#xA0; &#xA0;&#xA0; $my_input </span><span class="keyword">= </span><span class="default">htmlspecialchars</span><span class="keyword">( </span><span class="default">strip_tags</span><span class="keyword">(</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">&apos;foo&apos;</span><span class="keyword">]) );<br></span><span class="default">?&gt;<br></span><br>This will junk a lot of input you might actually want, if you&apos;re rolling your own forum or comments section and it&apos;s for web developers, for example.&#xA0; On the other hand, if legitimate users are never going to enter anything other than text, never HTML tags or anything else, it&apos;s not a bad idea.<br><br>The take-away is that mysqli_real_escape_string() is not good enough, and being overly-aggressive in sanitizing input may not be what you want.<br><br>Be aware that in the above example, it will protect you from sqli (run sqlmap on all your input fields and forms to check) but it won&apos;t protect your database from being filled with junk, effectively DoS&apos;ing your Web app in the process.<br><br>So after protecting against SQLi, even if you&apos;re behind CloudFlare and take other measures to protect your databases, there&apos;s still effectively a DoS attack that could slow down your Web App for legitimate users and make it a nightmare filled with rubbish that some poor maintainer has to clean out, if you don&apos;t take other measures.<br><br>So aside from escaping your stings, and protecting against SQLi and stored/reflected XSS, and maliciously loaded images or JS, there&apos;s also checking your input to see if it makes sense, so you don&apos;t get a database full of rubbish!<br><br>It just never ends... :-)</span>
</div>
  

#


<div class="phpcode"><span class="html">
Note that this function will NOT escape _ (underscore) and % (percent) signs, which have special meanings in LIKE clauses. <br><br>As far as I know there is no function to do this, so you have to escape them yourself by adding a backslash in front of them.</span>
</div>
  

#


<div class="phpcode"><span class="html">
When I submit data through Ajax I use a little function to reconvert the encoded chars to their original value. After that I do the escaping. Here the function:<br><br>&#xA0;&#xA0; function my_htmlentities($input){<br>&#xA0; &#xA0; &#xA0;&#xA0; $string = htmlentities($input,ENT_NOQUOTES,&apos;UTF-8&apos;);<br>&#xA0; &#xA0; &#xA0;&#xA0; $string = str_replace(&apos;&amp;euro;&apos;,chr(128),$string);<br>&#xA0; &#xA0; &#xA0;&#xA0; $string = html_entity_decode($string,ENT_NOQUOTES,&apos;ISO-8859-15&apos;);<br>&#xA0; &#xA0; &#xA0;&#xA0; return $string;<br>&#xA0;&#xA0; }<br><br>G.Zanferrari</span>
</div>
  

#


<div class="phpcode"><span class="html">
If you wonder why (besides \, &apos; and &quot;)&#xA0; NUL (ASCII 0), \n, \r, and Control-Z are escaped: it is not to prevent sql injection, but to prevent your sql logfile to get unreadable.</span>
</div>
  

#

[Official documentation page](https://www.php.net/manual/en/mysqli.real-escape-string.php)

**[To root](/README.md)**