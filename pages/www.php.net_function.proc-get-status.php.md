# proc_get_status



On Unix/Linux, if you change the command line you pass to proc_open() just slightly then proc_get_status() will give you the actual process-id (pid) of your child.<br><br>Suppose you wish to run the external command /usr/bin/compress to create a BSD foo.Z file.  Rather than proc_open("/usr/bin/compress /tmp/foo",...) you may invoke proc_open("exec /usr/bin/compress /tmp/foo",...) and then proc_get_status()[&apos;pid&apos;] will be the actual pid of /usr/bin/compress.<br><br>Why?  Because the way proc_open() actually works on Unix/Linux is by starting "/bin/sh -c usercmd userargs...", e.g., "/bin/sh -c /usr/bin/compress /tmp/foo".[Note 1]  That means normally your command is the child of the shell, so the pid you retrieve with proc_get_status() is the pid of the shell (PHP&apos;s child), and you have to fumble around trying to find the pid of your command (PHP&apos;s grandchild).  But if you put "exec" in front of your command, you tell the shell to *replace itself* with your command without starting another process (technically, to exec your command without forking first).  That means your command will inherit the pid of the shell, which is the pid that proc_get_status() returns.<br><br>So if you would like the actual pid of the process running your command, just prepend "exec " to  your proc_open() command argument then retrieve the pid using proc_get_status().<br><br>This also makes proc_terminate() and proc_close() work more like you might prefer, since they will affect the actual process running your command (which will be a child process rather than a grandchild process).<br><br>[Note 1] My guess is that the PHP developers want the shell to expand wildcards in path/filenames.  

#

It is worth noting that proc_get_status will continue to indicate the process that you spawned is running (because it is!) until that process has been able to write everything it wants to write to the STDOUT and STDERR streams.<br><br>PHP seems to use a buffer for this and so the spawned process can can get it&apos;s write calls to return immediately. <br><br>However, once this buffer is full the write call will block until you read out some of the information from the stream/pipe.<br><br>This can manifest itself in many ways but generally the called process will still be running, but just not doing anything as it is blocking on being able to write more to STDERR or STDOUT -- whichever stream buffer is full.<br><br>To work around this you should include in your loop of checking proc_get_status&apos; running element a "stream_get_contents" on the relevant pipes.<br><br>I generally use stream_set_blocking($pipies[2], 0) kind of calls to make sure that the stream_get_contents call will not block if there is no data in the stream.<br><br>This one had me stumped for a while, so hopefully it helps someone!  

#

[Official documentation page](https://www.php.net/manual/en/function.proc-get-status.php)

**[To root](/README.md)**