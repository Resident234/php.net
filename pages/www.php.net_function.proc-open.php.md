# proc_open




<div class="phpcode"><span class="html">
The call works as should. No bugs.<br>But. In most cases you won&apos;t able to work with pipes in blocking mode.<br>When your output pipe (process&apos; input one, $pipes[0]) is blocking, there is a case, when you and the process are blocked on output.<br>When your input pipe (process&apos; output one, $pipes[1]) is blocking, there is a case, when you and the process both are blocked on own input.<br>So you should switch pipes into NONBLOCKING mode (stream_set_blocking).<br>Then, there is a case, when you&apos;re not able to read anything (fread($pipes[1],...) == &quot;&quot;) either write (fwrite($pipes[0],...) == 0). In this case, you better check the process is alive (proc_get_status) and if it still is - wait for some time (stream_select). The situation is truly asynchronous, the process may be busy working, processing your data.<br>Using shell effectively makes not possible to know whether the command is exists - proc_open always returns valid resource. You may even write some data into it (into shell, actually). But eventually it will terminate, so check the process status regularly.<br>I would advice not using mkfifo-pipes, because filesystem fifo-pipe (mkfifo) blocks open/fopen call (!!!) until somebody opens other side (unix-related behavior). In case the pipe is opened not by shell and the command is crashed or is not exists you will be blocked forever.</span>
</div>
  

#


<div class="phpcode"><span class="html">
Note that when you call an external script and retrieve large amounts of data from STDOUT and STDERR, you may need to retrieve from both alternately in non-blocking mode (with appropriate pauses if no data is retrieved), so that your PHP script doesn&apos;t lock up. This can happen if you waiting on activity on one pipe while the external script is waiting for you to empty the other, e.g:<br><br><span class="default">&lt;?php<br>$read_output </span><span class="keyword">= </span><span class="default">$read_error </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">;<br></span><span class="default">$buffer_len&#xA0; </span><span class="keyword">= </span><span class="default">$prev_buffer_len </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; <br></span><span class="default">$ms&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="keyword">= </span><span class="default">10</span><span class="keyword">;<br></span><span class="default">$output&#xA0; &#xA0; &#xA0; </span><span class="keyword">= </span><span class="string">&apos;&apos;</span><span class="keyword">;<br></span><span class="default">$read_output </span><span class="keyword">= </span><span class="default">true</span><span class="keyword">;<br></span><span class="default">$error&#xA0; &#xA0; &#xA0;&#xA0; </span><span class="keyword">= </span><span class="string">&apos;&apos;</span><span class="keyword">;<br></span><span class="default">$read_error&#xA0; </span><span class="keyword">= </span><span class="default">true</span><span class="keyword">;<br></span><span class="default">stream_set_blocking</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">], </span><span class="default">0</span><span class="keyword">);<br></span><span class="default">stream_set_blocking</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">], </span><span class="default">0</span><span class="keyword">);<br><br></span><span class="comment">// dual reading of STDOUT and STDERR stops one full pipe blocking the other, because the external script is waiting<br></span><span class="keyword">while (</span><span class="default">$read_error </span><span class="keyword">!= </span><span class="default">false </span><span class="keyword">or </span><span class="default">$read_output </span><span class="keyword">!= </span><span class="default">false</span><span class="keyword">)<br>{<br>&#xA0; &#xA0; if (</span><span class="default">$read_output </span><span class="keyword">!= </span><span class="default">false</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; if(</span><span class="default">feof</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">])) <br>&#xA0; &#xA0; &#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$read_output </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">;<br>&#xA0; &#xA0; &#xA0; &#xA0; }<br>&#xA0; &#xA0; &#xA0; &#xA0; else <br>&#xA0; &#xA0; &#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">fgets</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">], </span><span class="default">1024</span><span class="keyword">);<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$len </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; if (</span><span class="default">$len</span><span class="keyword">)<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$output </span><span class="keyword">.= </span><span class="default">$str</span><span class="keyword">; <br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$buffer_len </span><span class="keyword">+= </span><span class="default">$len</span><span class="keyword">;<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; }<br>&#xA0; &#xA0; &#xA0; &#xA0; }<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; <br>&#xA0; &#xA0; if (</span><span class="default">$read_error </span><span class="keyword">!= </span><span class="default">false</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; if(</span><span class="default">feof</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">])) <br>&#xA0; &#xA0; &#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">]);<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$read_error </span><span class="keyword">= </span><span class="default">false</span><span class="keyword">;<br>&#xA0; &#xA0; &#xA0; &#xA0; }<br>&#xA0; &#xA0; &#xA0; &#xA0; else <br>&#xA0; &#xA0; &#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">fgets</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">], </span><span class="default">1024</span><span class="keyword">);<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$len </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; if (</span><span class="default">$len</span><span class="keyword">)<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$error </span><span class="keyword">.= </span><span class="default">$str</span><span class="keyword">; <br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$buffer_len </span><span class="keyword">+= </span><span class="default">$len</span><span class="keyword">;<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; }<br>&#xA0; &#xA0; &#xA0; &#xA0; }<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; <br>&#xA0; &#xA0; if (</span><span class="default">$buffer_len </span><span class="keyword">&gt; </span><span class="default">$prev_buffer_len</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$prev_buffer_len </span><span class="keyword">= </span><span class="default">$buffer_len</span><span class="keyword">;<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$ms </span><span class="keyword">= </span><span class="default">10</span><span class="keyword">;<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; else <br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">usleep</span><span class="keyword">(</span><span class="default">$ms </span><span class="keyword">* </span><span class="default">1000</span><span class="keyword">); </span><span class="comment">// sleep for $ms milliseconds<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="keyword">if (</span><span class="default">$ms </span><span class="keyword">&lt; </span><span class="default">160</span><span class="keyword">)<br>&#xA0; &#xA0; &#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">$ms </span><span class="keyword">= </span><span class="default">$ms </span><span class="keyword">* </span><span class="default">2</span><span class="keyword">;<br>&#xA0; &#xA0; &#xA0; &#xA0; }<br>&#xA0; &#xA0; }<br>}<br>&#xA0; &#xA0; &#xA0; &#xA0; <br>return </span><span class="default">proc_close</span><span class="keyword">(</span><span class="default">$process</span><span class="keyword">);<br></span><span class="default">?&gt;</span>
</span>
</div>
  

#


<div class="phpcode"><span class="html">
Interestingly enough, it seems you actually have to store the return value in order for your streams to exist. You can&apos;t throw it away.<br><br>In other words, this works:<br><br><span class="default">&lt;?php<br>$proc</span><span class="keyword">=</span><span class="default">proc_open</span><span class="keyword">(</span><span class="string">&quot;echo foo&quot;</span><span class="keyword">,<br>&#xA0; array(<br>&#xA0; &#xA0; array(</span><span class="string">&quot;pipe&quot;</span><span class="keyword">,</span><span class="string">&quot;r&quot;</span><span class="keyword">),<br>&#xA0; &#xA0; array(</span><span class="string">&quot;pipe&quot;</span><span class="keyword">,</span><span class="string">&quot;w&quot;</span><span class="keyword">),<br>&#xA0; &#xA0; array(</span><span class="string">&quot;pipe&quot;</span><span class="keyword">,</span><span class="string">&quot;w&quot;</span><span class="keyword">)<br>&#xA0; ),<br>&#xA0; </span><span class="default">$pipes</span><span class="keyword">);<br>print </span><span class="default">stream_get_contents</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);<br></span><span class="default">?&gt;<br></span><br>prints:<br>foo<br><br>but this doesn&apos;t work:<br><br><span class="default">&lt;?php<br>proc_open</span><span class="keyword">(</span><span class="string">&quot;echo foo&quot;</span><span class="keyword">,<br>&#xA0; array(<br>&#xA0; &#xA0; array(</span><span class="string">&quot;pipe&quot;</span><span class="keyword">,</span><span class="string">&quot;r&quot;</span><span class="keyword">),<br>&#xA0; &#xA0; array(</span><span class="string">&quot;pipe&quot;</span><span class="keyword">,</span><span class="string">&quot;w&quot;</span><span class="keyword">),<br>&#xA0; &#xA0; array(</span><span class="string">&quot;pipe&quot;</span><span class="keyword">,</span><span class="string">&quot;w&quot;</span><span class="keyword">)<br>&#xA0; ),<br>&#xA0; </span><span class="default">$pipes</span><span class="keyword">);<br>print </span><span class="default">stream_get_contents</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);<br></span><span class="default">?&gt;<br></span><br>outputs:<br>Warning: stream_get_contents(): &lt;n&gt; is not a valid stream resource in Command line code on line 1<br><br>The only difference is that in the second case we don&apos;t save the output of proc_open to a variable.</span>
</div>
  

#


<div class="phpcode"><span class="html">
It took me a long time (and three consecutive projects) to figure this out.&#xA0; Because popen() and proc_open() return valid processes even when the command failed it&apos;s awkward to determine when it really has failed if you&apos;re opening a non-interactive process like &quot;sendmail -t&quot;.<br><br>I had previously guess that reading from STDERR immediately after starting the process would work, and it does... but when the command is successful PHP just hangs because STDERR is empty and it&apos;s waiting for data to be written to it.<br><br>The solution is a simple stream_set_blocking($pipes[2], 0) immediately after calling proc_open().<br><br><span class="default">&lt;?php<br><br>&#xA0; &#xA0; $this</span><span class="keyword">-&gt;</span><span class="default">_proc </span><span class="keyword">= </span><span class="default">proc_open</span><span class="keyword">(</span><span class="default">$command</span><span class="keyword">, </span><span class="default">$descriptorSpec</span><span class="keyword">, </span><span class="default">$pipes</span><span class="keyword">);<br>&#xA0; &#xA0; </span><span class="default">stream_set_blocking</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">], </span><span class="default">0</span><span class="keyword">);<br>&#xA0; &#xA0; if (</span><span class="default">$err </span><span class="keyword">= </span><span class="default">stream_get_contents</span><span class="keyword">(</span><span class="default">$pipes</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">]))<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; throw new </span><span class="default">Swift_Transport_TransportException</span><span class="keyword">(<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="string">&apos;Process could not be started [&apos; </span><span class="keyword">. </span><span class="default">$err </span><span class="keyword">. </span><span class="string">&apos;]&apos;<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="keyword">);<br>&#xA0; &#xA0; }<br><br></span><span class="default">?&gt;<br></span><br>If the process is opened successfully $pipes[2] will be empty, but if it failed the bash/sh error will be in it.<br><br>Finally I can drop all my &quot;workaround&quot; error checking.<br><br>I realise this solution is obvious and I&apos;m not sure how it took me 18 months to figure it out, but hopefully this will help someone else.<br><br>NOTE: Make sure your descriptorSpec has ( 2 =&gt; array(&apos;pipe&apos;, &apos;w&apos;)) for this to work.</span>
</div>
  

#


<div class="phpcode"><span class="html">
It seems that stream_get_contents() on STDOUT blocks infinitly under Windows when STDERR is filled under some circumstances.<br><br>The trick is to open STDERR in append mode (&quot;a&quot;), then this will work, too.<br><br><span class="default">&lt;?php<br>$descriptorspec </span><span class="keyword">= array(<br>&#xA0; &#xA0; </span><span class="default">0 </span><span class="keyword">=&gt; array(</span><span class="string">&apos;pipe&apos;</span><span class="keyword">, </span><span class="string">&apos;r&apos;</span><span class="keyword">), </span><span class="comment">// stdin<br>&#xA0; &#xA0; </span><span class="default">1 </span><span class="keyword">=&gt; array(</span><span class="string">&apos;pipe&apos;</span><span class="keyword">, </span><span class="string">&apos;w&apos;</span><span class="keyword">), </span><span class="comment">// stdout<br>&#xA0; &#xA0; </span><span class="default">2 </span><span class="keyword">=&gt; array(</span><span class="string">&apos;pipe&apos;</span><span class="keyword">, </span><span class="string">&apos;a&apos;</span><span class="keyword">) </span><span class="comment">// stderr<br></span><span class="keyword">);<br></span><span class="default">?&gt;</span>
</span>
</div>
  

#

[Official documentation page](https://www.php.net/manual/en/function.proc-open.php)

**[To root](/README.md)**