# gethostbyaddr




<div class="phpcode"><span class="html">
Sometimes when using $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;] OR $_SERVER[&apos;REMOTE_ADDR&apos;] more than 1 IP address is returned, for example &apos;155.240.132.261, 196.250.25.120&apos;. When this string is passed as an argument for gethostbyaddr() PHP gives the following error: Warning: Address is not a valid IPv4 or IPv6 address in... <br><br>To work around this I use the following code to extract the first IP address from the string and discard the rest. (If you wish to use the other IPs they will be in the other elements of the $ips array).<br><br>if (strstr($remoteIP, &apos;, &apos;)) {<br>&#xA0; &#xA0; $ips = explode(&apos;, &apos;, $remoteIP);<br>&#xA0; &#xA0; $remoteIP = $ips[0];<br>}<br><br>Hope this helps someone :)</span>
</div>
  

#


<div class="phpcode"><span class="html">
The problem of broken DNS servers was causing me a problem because i had a page for user statistics that required around 20 reverse dns lookups to be done, and even as many as 5/6 of them being broken was causing a huge delay in loading the page. so i wrote a function that uses a UDP socket to talk directly to the DNS server (instead of going via the normal gethostbyaddr function) this let me set a timeout.<br><br>The only requirement is that your DNS server must be able to do recursive lookups, it wont go to other DNS servers if its told to... and of course you need to know your DNS servers IP address :-)<br><br>&lt;?<br>function gethostbyaddr_timeout($ip, $dns, $timeout=1000)<br>{<br>&#xA0; &#xA0; // random transaction number (for routers etc to get the reply back)<br>&#xA0; &#xA0; $data = rand(0, 99);<br>&#xA0; &#xA0; // trim it to 2 bytes<br>&#xA0; &#xA0; $data = substr($data, 0, 2);<br>&#xA0; &#xA0; // request header<br>&#xA0; &#xA0; $data .= &quot;\1\0\0\1\0\0\0\0\0\0&quot;;<br>&#xA0; &#xA0; // split IP up<br>&#xA0; &#xA0; $bits = explode(&quot;.&quot;, $ip);<br>&#xA0; &#xA0; // error checking<br>&#xA0; &#xA0; if (count($bits) != 4) return &quot;ERROR&quot;;<br>&#xA0; &#xA0; // there is probably a better way to do this bit...<br>&#xA0; &#xA0; // loop through each segment<br>&#xA0; &#xA0; for ($x=3; $x&gt;=0; $x--)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; // needs a byte to indicate the length of each segment of the request<br>&#xA0; &#xA0; &#xA0; &#xA0; switch (strlen($bits[$x]))<br>&#xA0; &#xA0; &#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; case 1: // 1 byte long segment<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; $data .= &quot;\1&quot;; break;<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; case 2: // 2 byte long segment<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; $data .= &quot;\2&quot;; break;<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; case 3: // 3 byte long segment<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; $data .= &quot;\3&quot;; break;<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; default: // segment is too big, invalid IP<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; return &quot;INVALID&quot;;<br>&#xA0; &#xA0; &#xA0; &#xA0; }<br>&#xA0; &#xA0; &#xA0; &#xA0; // and the segment itself<br>&#xA0; &#xA0; &#xA0; &#xA0; $data .= $bits[$x];<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; // and the final bit of the request<br>&#xA0; &#xA0; $data .= &quot;\7in-addr\4arpa\0\0\x0C\0\1&quot;;<br>&#xA0; &#xA0; // create UDP socket<br>&#xA0; &#xA0; $handle = @fsockopen(&quot;udp://$dns&quot;, 53);<br>&#xA0; &#xA0; // send our request (and store request size so we can cheat later)<br>&#xA0; &#xA0; $requestsize=@fwrite($handle, $data);<br><br>&#xA0; &#xA0; @socket_set_timeout($handle, $timeout - $timeout%1000, $timeout%1000);<br>&#xA0; &#xA0; // hope we get a reply<br>&#xA0; &#xA0; $response = @fread($handle, 1000);<br>&#xA0; &#xA0; @fclose($handle);<br>&#xA0; &#xA0; if ($response == &quot;&quot;)<br>&#xA0; &#xA0; &#xA0; &#xA0; return $ip;<br>&#xA0; &#xA0; // find the response type<br>&#xA0; &#xA0; $type = @unpack(&quot;s&quot;, substr($response, $requestsize+2));<br>&#xA0; &#xA0; if ($type[1] == 0x0C00)&#xA0; // answer<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; // set up our variables<br>&#xA0; &#xA0; &#xA0; &#xA0; $host=&quot;&quot;;<br>&#xA0; &#xA0; &#xA0; &#xA0; $len = 0;<br>&#xA0; &#xA0; &#xA0; &#xA0; // set our pointer at the beginning of the hostname<br>&#xA0; &#xA0; &#xA0; &#xA0; // uses the request size from earlier rather than work it out<br>&#xA0; &#xA0; &#xA0; &#xA0; $position=$requestsize+12;<br>&#xA0; &#xA0; &#xA0; &#xA0; // reconstruct hostname<br>&#xA0; &#xA0; &#xA0; &#xA0; do<br>&#xA0; &#xA0; &#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; // get segment size<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; $len = unpack(&quot;c&quot;, substr($response, $position));<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; // null terminated string, so length 0 = finished<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; if ($len[1] == 0)<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; // return the hostname, without the trailing .<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; return substr($host, 0, strlen($host) -1);<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; // add segment to our host<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; $host .= substr($response, $position+1, $len[1]) . &quot;.&quot;;<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; // move pointer on to the next segment<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; $position += $len[1] + 1;<br>&#xA0; &#xA0; &#xA0; &#xA0; }<br>&#xA0; &#xA0; &#xA0; &#xA0; while ($len != 0);<br>&#xA0; &#xA0; &#xA0; &#xA0; // error - return the hostname we constructed (without the . on the end)<br>&#xA0; &#xA0; &#xA0; &#xA0; return $ip;<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; return $ip;<br>}<br>?&gt;<br><br>This could be expanded quite a bit and improved but it works and i&apos;ve seen quite a few people trying various methods to achieve something like this so i decided to post it here. on most servers it should also be more efficient than other methods such as calling nslookup because it doesn&apos;t need to run external programs<br><br>Note: I&apos;m more a C person than a PHP person, so just ignore it if anything hasn&apos;t been done the *recomended* way :-)</span>
</div>
  

#

[Official documentation page](https://www.php.net/manual/en/function.gethostbyaddr.php)

**[To root](/README.md)**