# imap_fetchstructure




<div class="phpcode"><span class="html">
Here is code to parse and decode all types of messages, including attachments. I&apos;ve been using something like this for awhile now, so it&apos;s pretty robust.<br><br>&lt;?<br>function getmsg($mbox,$mid) {<br>&#xA0; &#xA0; // input $mbox = IMAP stream, $mid = message id<br>&#xA0; &#xA0; // output all the following:<br>&#xA0; &#xA0; global $charset,$htmlmsg,$plainmsg,$attachments;<br>&#xA0; &#xA0; $htmlmsg = $plainmsg = $charset = &apos;&apos;;<br>&#xA0; &#xA0; $attachments = array();<br><br>&#xA0; &#xA0; // HEADER<br>&#xA0; &#xA0; $h = imap_header($mbox,$mid);<br>&#xA0; &#xA0; // add code here to get date, from, to, cc, subject...<br><br>&#xA0; &#xA0; // BODY<br>&#xA0; &#xA0; $s = imap_fetchstructure($mbox,$mid);<br>&#xA0; &#xA0; if (!$s-&gt;parts)&#xA0; // simple<br>&#xA0; &#xA0; &#xA0; &#xA0; getpart($mbox,$mid,$s,0);&#xA0; // pass 0 as part-number<br>&#xA0; &#xA0; else {&#xA0; // multipart: cycle through each part<br>&#xA0; &#xA0; &#xA0; &#xA0; foreach ($s-&gt;parts as $partno0=&gt;$p)<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; getpart($mbox,$mid,$p,$partno0+1);<br>&#xA0; &#xA0; }<br>}<br><br>function getpart($mbox,$mid,$p,$partno) {<br>&#xA0; &#xA0; // $partno = &apos;1&apos;, &apos;2&apos;, &apos;2.1&apos;, &apos;2.1.3&apos;, etc for multipart, 0 if simple<br>&#xA0; &#xA0; global $htmlmsg,$plainmsg,$charset,$attachments;<br><br>&#xA0; &#xA0; // DECODE DATA<br>&#xA0; &#xA0; $data = ($partno)?<br>&#xA0; &#xA0; &#xA0; &#xA0; imap_fetchbody($mbox,$mid,$partno):&#xA0; // multipart<br>&#xA0; &#xA0; &#xA0; &#xA0; imap_body($mbox,$mid);&#xA0; // simple<br>&#xA0; &#xA0; // Any part may be encoded, even plain text messages, so check everything.<br>&#xA0; &#xA0; if ($p-&gt;encoding==4)<br>&#xA0; &#xA0; &#xA0; &#xA0; $data = quoted_printable_decode($data);<br>&#xA0; &#xA0; elseif ($p-&gt;encoding==3)<br>&#xA0; &#xA0; &#xA0; &#xA0; $data = base64_decode($data);<br><br>&#xA0; &#xA0; // PARAMETERS<br>&#xA0; &#xA0; // get all parameters, like charset, filenames of attachments, etc.<br>&#xA0; &#xA0; $params = array();<br>&#xA0; &#xA0; if ($p-&gt;parameters)<br>&#xA0; &#xA0; &#xA0; &#xA0; foreach ($p-&gt;parameters as $x)<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; $params[strtolower($x-&gt;attribute)] = $x-&gt;value;<br>&#xA0; &#xA0; if ($p-&gt;dparameters)<br>&#xA0; &#xA0; &#xA0; &#xA0; foreach ($p-&gt;dparameters as $x)<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; $params[strtolower($x-&gt;attribute)] = $x-&gt;value;<br><br>&#xA0; &#xA0; // ATTACHMENT<br>&#xA0; &#xA0; // Any part with a filename is an attachment,<br>&#xA0; &#xA0; // so an attached text file (type 0) is not mistaken as the message.<br>&#xA0; &#xA0; if ($params[&apos;filename&apos;] || $params[&apos;name&apos;]) {<br>&#xA0; &#xA0; &#xA0; &#xA0; // filename may be given as &apos;Filename&apos; or &apos;Name&apos; or both<br>&#xA0; &#xA0; &#xA0; &#xA0; $filename = ($params[&apos;filename&apos;])? $params[&apos;filename&apos;] : $params[&apos;name&apos;];<br>&#xA0; &#xA0; &#xA0; &#xA0; // filename may be encoded, so see imap_mime_header_decode()<br>&#xA0; &#xA0; &#xA0; &#xA0; $attachments[$filename] = $data;&#xA0; // this is a problem if two files have same name<br>&#xA0; &#xA0; }<br><br>&#xA0; &#xA0; // TEXT<br>&#xA0; &#xA0; if ($p-&gt;type==0 &amp;&amp; $data) {<br>&#xA0; &#xA0; &#xA0; &#xA0; // Messages may be split in different parts because of inline attachments,<br>&#xA0; &#xA0; &#xA0; &#xA0; // so append parts together with blank row.<br>&#xA0; &#xA0; &#xA0; &#xA0; if (strtolower($p-&gt;subtype)==&apos;plain&apos;)<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; $plainmsg. = trim($data) .&quot;\n\n&quot;;<br>&#xA0; &#xA0; &#xA0; &#xA0; else<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; $htmlmsg. = $data .&quot;&lt;br&gt;&lt;br&gt;&quot;;<br>&#xA0; &#xA0; &#xA0; &#xA0; $charset = $params[&apos;charset&apos;];&#xA0; // assume all parts are same charset<br>&#xA0; &#xA0; }<br><br>&#xA0; &#xA0; // EMBEDDED MESSAGE<br>&#xA0; &#xA0; // Many bounce notifications embed the original message as type 2,<br>&#xA0; &#xA0; // but AOL uses type 1 (multipart), which is not handled here.<br>&#xA0; &#xA0; // There are no PHP functions to parse embedded messages,<br>&#xA0; &#xA0; // so this just appends the raw source to the main message.<br>&#xA0; &#xA0; elseif ($p-&gt;type==2 &amp;&amp; $data) {<br>&#xA0; &#xA0; &#xA0; &#xA0; $plainmsg. = $data.&quot;\n\n&quot;;<br>&#xA0; &#xA0; }<br><br>&#xA0; &#xA0; // SUBPART RECURSION<br>&#xA0; &#xA0; if ($p-&gt;parts) {<br>&#xA0; &#xA0; &#xA0; &#xA0; foreach ($p-&gt;parts as $partno0=&gt;$p2)<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; getpart($mbox,$mid,$p2,$partno.&apos;.&apos;.($partno0+1));&#xA0; // 1.2, 1.2.1, etc.<br>&#xA0; &#xA0; }<br>}<br>?&gt;</span>
</div>
  

#

[Official documentation page](https://www.php.net/manual/en/function.imap-fetchstructure.php)

**[To root](/README.md)**