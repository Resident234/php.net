# Object Interfaces




<div class="phpcode"><span class="html">
It seems like many contributors are missing the point of using an INTERFACE. An INTERFACE is not specifically provided for abstraction. That&apos;s what a CLASS is used for. Most examples in this article of interfaces could be achieved just as easily using just classes alone. <br><br>An INTERFACE is provided so you can describe a set of functions and then hide the final implementation of those functions in an implementing class. This allows you to change the IMPLEMENTATION of those functions without changing how you use it. <br><br>For example: I have a database. I want to write a class that accesses the data in my database. I define an interface like this:<br><br>interface Database {<br>function listOrders();<br>function addOrder();<br>function removeOrder();<br>...<br>}<br><br>Then let&apos;s say we start out using a MySQL database. So we write a class to access the MySQL database:<br><br>class MySqlDatabase implements Database {<br>function listOrders() {...<br>}<br>we write these methods as needed to get to the MySQL database tables. Then you can write your controller to use the interface as such:<br><br>$database = new MySqlDatabase();<br>foreach ($database-&gt;listOrders() as $order) {<br><br>Then let&apos;s say we decide to migrate to an Oracle database. We could write another class to get to the Oracle database as such:<br><br>class OracleDatabase implements Database {<br>public function listOrders() {...<br>}<br><br>Then - to switch our application to use the Oracle database instead of the MySQL database we only have to change ONE LINE of code:<br><br>$database = new OracleDatabase();<br><br>all other lines of code, such as:<br><br>foreach ($database-&gt;listOrders() as $order) {<br><br>will remain unchanged. The point is - the INTERFACE describes the methods that we need to access our database. It does NOT describe in any way HOW we achieve that. That&apos;s what the IMPLEMENTing class does. We can IMPLEMENT this interface as many times as we need in as many different ways as we need. We can then switch between implementations of the interface without impact to our code because the interface defines how we will use it regardless of how it actually works.</span>
</div>
  

#


<div class="phpcode"><span class="html">
Just wrote some examples of duck-typing in PHP. Sharing here.<br><br><span class="default">&lt;?php<br><br></span><span class="comment">/**<br> * An example of duck typing in PHP<br> */<br><br></span><span class="keyword">interface </span><span class="default">CanFly </span><span class="keyword">{<br>&#xA0; public function </span><span class="default">fly</span><span class="keyword">();<br>}<br><br>interface </span><span class="default">CanSwim </span><span class="keyword">{<br>&#xA0; public function </span><span class="default">swim</span><span class="keyword">();<br>}<br><br>class </span><span class="default">Bird </span><span class="keyword">{<br>&#xA0; public function </span><span class="default">info</span><span class="keyword">() {<br>&#xA0; &#xA0; echo </span><span class="string">&quot;I am a </span><span class="keyword">{</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">name</span><span class="keyword">}</span><span class="string">\n&quot;</span><span class="keyword">;<br>&#xA0; &#xA0; echo </span><span class="string">&quot;I am an bird\n&quot;</span><span class="keyword">;<br>&#xA0; }<br>}<br><br></span><span class="comment">/**<br> * some implementations of birds<br> */<br></span><span class="keyword">class </span><span class="default">Dove </span><span class="keyword">extends </span><span class="default">Bird </span><span class="keyword">implements </span><span class="default">CanFly </span><span class="keyword">{<br>&#xA0; var </span><span class="default">$name </span><span class="keyword">= </span><span class="string">&quot;Dove&quot;</span><span class="keyword">;<br>&#xA0; public function </span><span class="default">fly</span><span class="keyword">() {<br>&#xA0; &#xA0; echo </span><span class="string">&quot;I fly\n&quot;</span><span class="keyword">;<br>&#xA0; } <br>}<br><br>class </span><span class="default">Penguin </span><span class="keyword">extends </span><span class="default">Bird </span><span class="keyword">implements </span><span class="default">CanSwim </span><span class="keyword">{<br>&#xA0; var </span><span class="default">$name </span><span class="keyword">= </span><span class="string">&quot;Penguin&quot;</span><span class="keyword">;<br>&#xA0; public function </span><span class="default">swim</span><span class="keyword">() {<br>&#xA0; &#xA0; echo </span><span class="string">&quot;I swim\n&quot;</span><span class="keyword">;<br>&#xA0; } <br>}<br><br>class </span><span class="default">Duck </span><span class="keyword">extends </span><span class="default">Bird </span><span class="keyword">implements </span><span class="default">CanFly</span><span class="keyword">, </span><span class="default">CanSwim </span><span class="keyword">{<br>&#xA0; var </span><span class="default">$name </span><span class="keyword">= </span><span class="string">&quot;Duck&quot;</span><span class="keyword">;<br>&#xA0; public function </span><span class="default">fly</span><span class="keyword">() {<br>&#xA0; &#xA0; echo </span><span class="string">&quot;I fly\n&quot;</span><span class="keyword">;<br>&#xA0; }<br>&#xA0; public function </span><span class="default">swim</span><span class="keyword">() {<br>&#xA0; &#xA0; echo </span><span class="string">&quot;I swim\n&quot;</span><span class="keyword">;<br>&#xA0; }<br>}<br><br></span><span class="comment">/**<br> * a simple function to describe a bird<br> */<br></span><span class="keyword">function </span><span class="default">describe</span><span class="keyword">(</span><span class="default">$bird</span><span class="keyword">) {<br>&#xA0; if (</span><span class="default">$bird </span><span class="keyword">instanceof </span><span class="default">Bird</span><span class="keyword">) {<br>&#xA0; &#xA0; </span><span class="default">$bird</span><span class="keyword">-&gt;</span><span class="default">info</span><span class="keyword">();<br>&#xA0; &#xA0; if (</span><span class="default">$bird </span><span class="keyword">instanceof </span><span class="default">CanFly</span><span class="keyword">) {<br>&#xA0; &#xA0; &#xA0; </span><span class="default">$bird</span><span class="keyword">-&gt;</span><span class="default">fly</span><span class="keyword">();<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; if (</span><span class="default">$bird </span><span class="keyword">instanceof </span><span class="default">CanSwim</span><span class="keyword">) {<br>&#xA0; &#xA0; &#xA0; </span><span class="default">$bird</span><span class="keyword">-&gt;</span><span class="default">swim</span><span class="keyword">();<br>&#xA0; &#xA0; }<br>&#xA0; } else {<br>&#xA0; &#xA0; die(</span><span class="string">&quot;This is not a bird. I cannot describe it.&quot;</span><span class="keyword">);<br>&#xA0; }<br>}<br><br></span><span class="comment">// describe these birds please<br></span><span class="default">describe</span><span class="keyword">(new </span><span class="default">Penguin</span><span class="keyword">);<br>echo </span><span class="string">&quot;---\n&quot;</span><span class="keyword">;<br><br></span><span class="default">describe</span><span class="keyword">(new </span><span class="default">Dove</span><span class="keyword">);<br>echo </span><span class="string">&quot;---\n&quot;</span><span class="keyword">;<br><br></span><span class="default">describe</span><span class="keyword">(new </span><span class="default">Duck</span><span class="keyword">);</span>
</span>
</div>
  

#


<div class="phpcode"><span class="html">
If it&apos;s not already obvious, it&apos;s worth noticing that the parameters in the interface&apos;s method declaration do not have to have the same names as those in any of its implementations.<br><br>More significantly, default argument values may be supplied for interface method parameters, and they have to be if you want to use default argument values in the implemented classes:<br><br><span class="default">&lt;?php<br></span><span class="keyword">interface </span><span class="default">isStuffable<br></span><span class="keyword">{<br>&#xA0; &#xA0; public function </span><span class="default">getStuffed</span><span class="keyword">(</span><span class="default">$ratio</span><span class="keyword">=</span><span class="default">0.5</span><span class="keyword">);<br>}<br><br>class </span><span class="default">Turkey </span><span class="keyword">implements </span><span class="default">isStuffable<br></span><span class="keyword">{<br>&#xA0; &#xA0; public function </span><span class="default">getStuffed</span><span class="keyword">(</span><span class="default">$stuffing</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="comment">// ....<br>&#xA0; &#xA0; </span><span class="keyword">}<br>}<br></span><span class="default">?&gt;<br></span><br>Note that not only do the parameters have different names ($ratio and $stuffing), but their default values are free to be different as well. There doesn&apos;t seem to be any purpose to the interface&apos;s default argument value except as a dummy placeholder to show that there is a default (a class implementing isStuffable will not be able to implement methods with the signatures getStuffed(), getStuffed($a), or getStuffed($a,$b)).</span>
</div>
  

#


<div class="phpcode"><span class="html">
The class implementing the interface must use the exact same method signatures as are defined in the interface. Not doing so will result in a fatal error. -- this documentation page.<br><br>But, if you use default values in arguments in methods, fatal error is not follow:<br><br><span class="default">&lt;?php<br></span><span class="keyword">interface </span><span class="default">myInterface </span><span class="keyword">{<br>&#xA0; &#xA0; public function </span><span class="default">__construct</span><span class="keyword">();<br>}<br><br>class </span><span class="default">concret </span><span class="keyword">implements </span><span class="default">myInterface </span><span class="keyword">{<br><br>&#xA0; &#xA0; public function </span><span class="default">__construct</span><span class="keyword">(</span><span class="default">$arg</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">func_get_args</span><span class="keyword">());<br>&#xA0; &#xA0; }<br>}<br><br></span><span class="default">$obj </span><span class="keyword">= new </span><span class="default">concret</span><span class="keyword">(</span><span class="default">123</span><span class="keyword">);<br></span><span class="default">?&gt;<br></span><br>Array ( [0] =&gt; 123 )</span>
</div>
  

#


<div class="phpcode"><span class="html">
When should you use interfaces?&#xA0; What are they good for? <br>Here are two examples.&#xA0; <br><br>1. Interfaces are an excellent way to implement reusability.&#xA0; <br>You can create a general interface for a number of situations <br>(such as a save to/load from disk interface.)&#xA0; You can then <br>implement the interface in a variety of different ways (e.g. for <br>formats such as tab delimited ASCII, XML and a database.)&#xA0; <br>You can write code that asks the object to &quot;save itself to <br>disk&quot; without having to worry what that means for the object <br>in question.&#xA0; One object might save itself to the database, <br>another to an XML and you can change this behavior over <br>time without having to rewrite the calling code.&#xA0; <br><br>This allows you to write reusable calling code that can work <br>for any number of different objects -- you don&apos;t need to know <br>what kind of object it is, as long as it obeys the common <br>interface.&#xA0; <br><br>2. Interfaces can also promote gradual evolution.&#xA0; On a <br>recent project I had some very complicated work to do and I <br>didn&apos;t know how to implement it.&#xA0; I could think of a &quot;basic&quot; <br>implementation but I knew I would have to change it later.&#xA0; <br>So I created interfaces in each of these cases, and created <br>at least one &quot;basic&quot; implementation of the interface that <br>was &quot;good enough for now&quot; even though I knew it would have <br>to change later.&#xA0; <br><br>When I came back to make the changes, I was able to create <br>some new implementations of these interfaces that added the <br>extra features I needed.&#xA0; Some of my classes still used <br>the &quot;basic&quot; implementations, but others needed the <br>specialized ones.&#xA0; I was able to add the new features to the <br>objects themselves without rewriting the calling code in most <br>cases.&#xA0; It was easy to evolve my code in this way because <br>the changes were mostly isolated -- they didn&apos;t spread all <br>over the place like you might expect.</span>
</div>
  

#


<div class="phpcode"><span class="html">
Implementation must be strict, subtypes are not allowed.<br><br>&quot;The class implementing the interface must use the EXACT SAME METHOD SIGNATURES as are defined in the interface. Not doing so will result in a fatal error. &quot;<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">interface </span><span class="default">I<br></span><span class="keyword">{<br>&#xA0; function </span><span class="default">foo</span><span class="keyword">(</span><span class="default">stdClass $arg</span><span class="keyword">);<br>}<br><br>class </span><span class="default">Test </span><span class="keyword">extends </span><span class="default">stdClass<br></span><span class="keyword">{<br>}<br><br>class </span><span class="default">Implementation </span><span class="keyword">implements </span><span class="default">I<br></span><span class="keyword">{<br>&#xA0; function </span><span class="default">foo</span><span class="keyword">(</span><span class="default">Test $arg</span><span class="keyword">)<br>&#xA0; &#xA0; {<br>&#xA0; &#xA0; }<br>}<br></span><span class="default">?&gt;<br></span>Result:<br><br>Fatal error: Declaration of InterfaceImplementation::foo() must be compatible with I::foo(stdClass $arg) in test.php on line XY</span>
</div>
  

#


<div class="phpcode"><span class="html">
On an incidental note, it is not necessary for the implementation of an interface method to use the same variable names for its parameters that were used in the interface declaration.<br><br>More significantly, your interface method declarations can include default argument values. If you do, you must specify their implementations with default arguments, too. Just like the parameter names, the default argument values do not need to be the same. In fact, there doesn&apos;t seem to be any functionality to the one in the interface declaration at all beyond the fact that it is there.<br><br><span class="default">&lt;?php<br></span><span class="keyword">interface </span><span class="default">isStuffed </span><span class="keyword">{<br>&#xA0; &#xA0; public function </span><span class="default">getStuff</span><span class="keyword">(</span><span class="default">$something</span><span class="keyword">=</span><span class="default">17</span><span class="keyword">);<br>}<br><br>class </span><span class="default">oof </span><span class="keyword">implements </span><span class="default">isStuffed </span><span class="keyword">{<br>&#xA0; &#xA0; public function </span><span class="default">getStuff</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">=</span><span class="default">42</span><span class="keyword">) {<br>&#xA0; &#xA0; &#xA0; &#xA0; return </span><span class="default">$a</span><span class="keyword">;<br>&#xA0; &#xA0; }<br>}<br><br></span><span class="default">$oof </span><span class="keyword">= new </span><span class="default">oof</span><span class="keyword">;<br><br>echo </span><span class="default">$oof</span><span class="keyword">-&gt;</span><span class="default">getStuff</span><span class="keyword">();<br></span><span class="default">?&gt;<br></span><br>Implementations that try to declare the method as getStuff(), getStuff($a), or getStuff($a,$b) will all trigger a fatal error.</span>
</div>
  

#


<div class="phpcode"><span class="html">
I was wondering if implementing interfaces will take into account inheritance. That is, can inherited methods be used to follow an interface&apos;s structure?<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">interface </span><span class="default">Auxiliary_Platform </span><span class="keyword">{<br>&#xA0; &#xA0; public function </span><span class="default">Weapon</span><span class="keyword">();<br>&#xA0; &#xA0; public function </span><span class="default">Health</span><span class="keyword">();<br>&#xA0; &#xA0; public function </span><span class="default">Shields</span><span class="keyword">();<br>}<br><br>class </span><span class="default">T805 </span><span class="keyword">implements </span><span class="default">Auxiliary_Platform </span><span class="keyword">{<br>&#xA0; &#xA0; public function </span><span class="default">Weapon</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">__CLASS__</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; public function </span><span class="default">Health</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">__CLASS__ </span><span class="keyword">. </span><span class="string">&quot;::&quot; </span><span class="keyword">. </span><span class="default">__FUNCTION__</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; public function </span><span class="default">Shields</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">__CLASS__ </span><span class="keyword">. </span><span class="string">&quot;-&gt;&quot; </span><span class="keyword">. </span><span class="default">__FUNCTION__</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>}<br><br>class </span><span class="default">T806 </span><span class="keyword">extends </span><span class="default">T805 </span><span class="keyword">implements </span><span class="default">Auxiliary_Platform </span><span class="keyword">{<br>&#xA0; &#xA0; public function </span><span class="default">Weapon</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">__CLASS__</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; public function </span><span class="default">Shields</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">__CLASS__ </span><span class="keyword">. </span><span class="string">&quot;-&gt;&quot; </span><span class="keyword">. </span><span class="default">__FUNCTION__</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>}<br><br></span><span class="default">$T805 </span><span class="keyword">= new </span><span class="default">T805</span><span class="keyword">();<br></span><span class="default">$T805</span><span class="keyword">-&gt;</span><span class="default">Weapon</span><span class="keyword">();<br></span><span class="default">$T805</span><span class="keyword">-&gt;</span><span class="default">Health</span><span class="keyword">();<br></span><span class="default">$T805</span><span class="keyword">-&gt;</span><span class="default">Shields</span><span class="keyword">();<br><br>echo </span><span class="string">&quot;&lt;hr /&gt;&quot;</span><span class="keyword">;<br><br></span><span class="default">$T806 </span><span class="keyword">= new </span><span class="default">T806</span><span class="keyword">();<br></span><span class="default">$T806</span><span class="keyword">-&gt;</span><span class="default">Weapon</span><span class="keyword">();<br></span><span class="default">$T806</span><span class="keyword">-&gt;</span><span class="default">Health</span><span class="keyword">();<br></span><span class="default">$T806</span><span class="keyword">-&gt;</span><span class="default">Shields</span><span class="keyword">();<br><br></span><span class="comment">/* Output:<br>string(4) &quot;T805&quot;<br>string(12) &quot;T805::Health&quot;<br>string(13) &quot;T805-&gt;Shields&quot;<br>&lt;hr /&gt;string(4) &quot;T806&quot;<br>string(12) &quot;T805::Health&quot;<br>string(13) &quot;T806-&gt;Shields&quot;<br>*/<br><br></span><span class="default">?&gt;<br></span><br>Class T805 implements the interface Auxiliary_Platform. T806 does the same thing, but the method Health() is inherited from T805 (not the exact case, but you get the idea). PHP seems to be fine with this and everything still works fine. Do note that the rules for class inheritance doesn&apos;t change in this scenario.<br><br>If the code were to be the same, but instead T805 (or T806) DOES NOT implement Auxiliary_Platform, then it&apos;ll still work. Since T805 already follows the interface, everything that inherits T805 will also be valid. I would be careful about that. Personally, I don&apos;t consider this a bug.<br><br>This seems to work in PHP5.2.9-2, PHP5.3 and PHP5.3.1 (my current versions).<br><br>We could also do the opposite:<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">class </span><span class="default">T805 </span><span class="keyword">{<br>&#xA0; &#xA0; public function </span><span class="default">Weapon</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">__CLASS__</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>}<br><br>class </span><span class="default">T806 </span><span class="keyword">extends </span><span class="default">T805 </span><span class="keyword">implements </span><span class="default">Auxiliary_Platform </span><span class="keyword">{<br>&#xA0; &#xA0; public function </span><span class="default">Health</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">__CLASS__ </span><span class="keyword">. </span><span class="string">&quot;::&quot; </span><span class="keyword">. </span><span class="default">__FUNCTION__</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>&#xA0; &#xA0; public function </span><span class="default">Shields</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">__CLASS__ </span><span class="keyword">. </span><span class="string">&quot;-&gt;&quot; </span><span class="keyword">. </span><span class="default">__FUNCTION__</span><span class="keyword">);<br>&#xA0; &#xA0; }<br>}<br><br></span><span class="default">$T805 </span><span class="keyword">= new </span><span class="default">T805</span><span class="keyword">();<br></span><span class="default">$T805</span><span class="keyword">-&gt;</span><span class="default">Weapon</span><span class="keyword">();<br><br>echo </span><span class="string">&quot;&lt;hr /&gt;&quot;</span><span class="keyword">;<br><br></span><span class="default">$T806 </span><span class="keyword">= new </span><span class="default">T806</span><span class="keyword">();<br></span><span class="default">$T806</span><span class="keyword">-&gt;</span><span class="default">Weapon</span><span class="keyword">();<br></span><span class="default">$T806</span><span class="keyword">-&gt;</span><span class="default">Health</span><span class="keyword">();<br></span><span class="default">$T806</span><span class="keyword">-&gt;</span><span class="default">Shields</span><span class="keyword">();<br><br></span><span class="comment">/* Output:<br>string(4) &quot;T805&quot;<br>&lt;hr /&gt;string(4) &quot;T805&quot;<br>string(12) &quot;T806::Health&quot;<br>string(13) &quot;T806-&gt;Shields&quot;<br>*/<br><br></span><span class="default">?&gt;<br></span><br>This works as well, but the output is different. I&apos;d be careful with this.</span>
</div>
  

#


<div class="phpcode"><span class="html">
PHP prevents interface a contant to be overridden by a class/interface that DIRECTLY inherits it.&#xA0; However, further inheritance allows it.&#xA0; That means that interface constants are not final as mentioned in a previous comment.&#xA0; Is this a bug or a feature?<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">interface </span><span class="default">a<br></span><span class="keyword">{<br>&#xA0; &#xA0; const </span><span class="default">b </span><span class="keyword">= </span><span class="string">&apos;Interface constant&apos;</span><span class="keyword">;<br>}<br><br></span><span class="comment">// Prints: Interface constant<br></span><span class="keyword">echo </span><span class="default">a</span><span class="keyword">::</span><span class="default">b</span><span class="keyword">;<br><br>class </span><span class="default">b </span><span class="keyword">implements </span><span class="default">a<br></span><span class="keyword">{<br>}<br><br></span><span class="comment">// This works!!!<br></span><span class="keyword">class </span><span class="default">c </span><span class="keyword">extends </span><span class="default">b<br></span><span class="keyword">{<br>&#xA0; &#xA0; const </span><span class="default">b </span><span class="keyword">= </span><span class="string">&apos;Class constant&apos;</span><span class="keyword">;<br>}<br><br>echo </span><span class="default">c</span><span class="keyword">::</span><span class="default">b</span><span class="keyword">;<br></span><span class="default">?&gt;</span>
</span>
</div>
  

#


<div class="phpcode"><span class="html">
The statement, that you have to implement _all_ methods of an interface has not to be taken that seriously, at least if you declare an abstract class and want to force the inheriting subclasses to implement the interface.<br>Just leave out all methods that should be implemented by the subclasses. But never write something like this:<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">interface </span><span class="default">Foo </span><span class="keyword">{<br><br>&#xA0; &#xA0; &#xA0; function </span><span class="default">bar</span><span class="keyword">();<br><br>}<br><br>abstract class </span><span class="default">FooBar </span><span class="keyword">implements </span><span class="default">Foo </span><span class="keyword">{<br><br>&#xA0; &#xA0; &#xA0;&#xA0; abstract function </span><span class="default">bar</span><span class="keyword">(); </span><span class="comment">// just for making clear, that this<br>&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;&#xA0; // method has to be implemented<br><br></span><span class="keyword">}<br><br></span><span class="default">?&gt;<br></span><br>This will end up with the following error-message:<br><br>Fatal error: Can&apos;t inherit abstract function Foo::bar() (previously declared abstract in FooBar) in path/to/file on line anylinenumber</span>
</div>
  

#


<div class="phpcode"><span class="html">
Interfaces can define static methods, but note that this won&apos;t make sense as you&apos;ll be using the class name and not polymorphism.<br><br>...Unless you have PHP 5.3 which supports late static binding:<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">interface </span><span class="default">IDoSomething </span><span class="keyword">{<br>&#xA0; &#xA0; public static function </span><span class="default">doSomething</span><span class="keyword">();<br>}<br><br>class </span><span class="default">One </span><span class="keyword">implements </span><span class="default">IDoSomething </span><span class="keyword">{<br>&#xA0; &#xA0; public static function </span><span class="default">doSomething</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; echo </span><span class="string">&quot;One is doing something\n&quot;</span><span class="keyword">;<br>&#xA0; &#xA0; }<br>}<br><br>class </span><span class="default">Two </span><span class="keyword">extends </span><span class="default">One </span><span class="keyword">{<br>&#xA0; &#xA0; public static function </span><span class="default">doSomething</span><span class="keyword">() {<br>&#xA0; &#xA0; &#xA0; &#xA0; echo </span><span class="string">&quot;Two is doing something\n&quot;</span><span class="keyword">;<br>&#xA0; &#xA0; }<br>}<br><br>function </span><span class="default">example</span><span class="keyword">(</span><span class="default">IDoSomething $doer</span><span class="keyword">) {<br>&#xA0; &#xA0; </span><span class="default">$doer</span><span class="keyword">::</span><span class="default">doSomething</span><span class="keyword">(); </span><span class="comment">// &quot;unexpected ::&quot; in PHP 5.2<br></span><span class="keyword">}<br><br></span><span class="default">example</span><span class="keyword">(new </span><span class="default">One</span><span class="keyword">()); </span><span class="comment">// One is doing something<br></span><span class="default">example</span><span class="keyword">(new </span><span class="default">Two</span><span class="keyword">()); </span><span class="comment">// Two is doing something<br><br></span><span class="default">?&gt;<br></span><br>If you have PHP 5.2 you can still declare static methods in interfaces. While you won&apos;t be able to call them via LSB, the &quot;implements IDoSomething&quot; can serve as a hint/reminder to other developers by saying &quot;this class has a ::doSomething() method&quot;.<br>Besides, you&apos;ll be upgrading to 5.3 soon, right? Right?<br><br>(Heh. I just realized: &quot;I do something&quot;. Unintentional, I swear!)</span>
</div>
  

#


<div class="phpcode"><span class="html">
What is not mentioned in the manual is that you can use &quot;self&quot; to force object hinting on a method of the implementing class:<br><br>Consider the following interface:<br><span class="default">&lt;?php<br></span><span class="keyword">interface </span><span class="default">Comparable<br></span><span class="keyword">{function </span><span class="default">compare</span><span class="keyword">(</span><span class="default">self $compare</span><span class="keyword">);}<br></span><span class="default">?&gt;<br></span><br>Which is then implemented:<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">class </span><span class="default">String </span><span class="keyword">implements </span><span class="default">Comparable<br></span><span class="keyword">{<br>&#xA0; &#xA0; private </span><span class="default">$string</span><span class="keyword">;<br>&#xA0; &#xA0; function </span><span class="default">__construct</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">)<br>&#xA0; &#xA0; {</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">string </span><span class="keyword">= </span><span class="default">$string</span><span class="keyword">;}<br>&#xA0; &#xA0; function </span><span class="default">compare</span><span class="keyword">(</span><span class="default">self $compare</span><span class="keyword">)<br>&#xA0; &#xA0; {return </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">string </span><span class="keyword">== </span><span class="default">$compare</span><span class="keyword">-&gt;</span><span class="default">string</span><span class="keyword">;}<br>}<br><br>class </span><span class="default">Integer </span><span class="keyword">implements </span><span class="default">Comparable<br></span><span class="keyword">{<br>&#xA0; &#xA0; private </span><span class="default">$integer</span><span class="keyword">;<br>&#xA0; &#xA0; function </span><span class="default">__construct</span><span class="keyword">(</span><span class="default">$int</span><span class="keyword">)<br>&#xA0; &#xA0; {</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">integer </span><span class="keyword">= </span><span class="default">$int</span><span class="keyword">;}<br>&#xA0; &#xA0; function </span><span class="default">compare</span><span class="keyword">(</span><span class="default">self $compare</span><span class="keyword">)<br>&#xA0; &#xA0; {return </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">integer </span><span class="keyword">== </span><span class="default">$compare</span><span class="keyword">-&gt;</span><span class="default">integer</span><span class="keyword">;}<br>}<br><br></span><span class="default">?&gt;<br></span><br>Comparing Integer with String will result in a fatal error, as it is not an instance of the same class:<br><br><span class="default">&lt;?php<br>$first_int </span><span class="keyword">= new </span><span class="default">Integer</span><span class="keyword">(</span><span class="default">3</span><span class="keyword">);<br></span><span class="default">$second_int </span><span class="keyword">= new </span><span class="default">Integer</span><span class="keyword">(</span><span class="default">3</span><span class="keyword">);<br></span><span class="default">$first_string </span><span class="keyword">= new </span><span class="default">String</span><span class="keyword">(</span><span class="string">&quot;foo&quot;</span><span class="keyword">);<br></span><span class="default">$second_string </span><span class="keyword">= new </span><span class="default">String</span><span class="keyword">(</span><span class="string">&quot;bar&quot;</span><span class="keyword">);<br><br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$first_int</span><span class="keyword">-&gt;</span><span class="default">compare</span><span class="keyword">(</span><span class="default">$second_int</span><span class="keyword">)); </span><span class="comment">// bool(true)<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$first_string</span><span class="keyword">-&gt;</span><span class="default">compare</span><span class="keyword">(</span><span class="default">$second_string</span><span class="keyword">)); </span><span class="comment">// bool(false)<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$first_string</span><span class="keyword">-&gt;</span><span class="default">compare</span><span class="keyword">(</span><span class="default">$second_int</span><span class="keyword">)); </span><span class="comment">// Fatal Error<br></span><span class="default">?&gt;</span>
</span>
</div>
  

#

[Official documentation page](https://www.php.net/manual/en/language.oop5.interfaces.php)

**[To root](/README.md)**